import * as vscode from 'vscode'
import { CloudSyncConfig, CloudSyncStatus, CodeSnippetDeprecatedType, DirectoryDeprecatedType } from '../types/types'
import { SettingsManager } from './settingsManager'
import { ContextManager } from './contextManager'
import { TempFilesCleaner } from './cleanupTempFiles'
import * as crypto from 'crypto'
import * as path from 'path'
import * as fs from 'fs'
import { simpleGit, SimpleGit, CleanOptions } from 'simple-git'
import { diffLines, diffWordsWithSpace } from 'diff'
import { diff3Merge } from 'node-diff3'


interface SyncResult {
  success: boolean
  message: string
  conflictsDetected?: boolean
  conflictDetails?: string[]
}

export class CloudSyncManager {
  private git: SimpleGit | null = null // Git client instance
  private config: CloudSyncConfig
  private context: vscode.ExtensionContext | null = null
  private storageManager: any = null

  constructor(context?: vscode.ExtensionContext, storageManager?: any) {
    this.config = SettingsManager.getCloudSyncConfig()
    this.context = context || null
    this.storageManager = storageManager || null
  }

  /**
   * æ›´æ–°é…ç½®å¹¶é‡æ–°åˆå§‹åŒ–Gitå®¢æˆ·ç«¯
   */
  public async updateConfig(newConfig: CloudSyncConfig): Promise<{ platformChanged: boolean; needsAttention: boolean; message?: string }> {
    const oldConfig = this.config
    this.config = newConfig
    this.git = null // Reset git client to reinitialize with new config
    
    // æ£€æŸ¥æ˜¯å¦å‘ç”Ÿäº†å¹³å°å˜æ›´
    const platformChanged = oldConfig.provider !== newConfig.provider || 
                           oldConfig.repositoryUrl !== newConfig.repositoryUrl
    
    if (!platformChanged) {
      return { platformChanged: false, needsAttention: false }
    }
    
    // å¦‚æœå¹³å°å‘ç”Ÿå˜æ›´ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰çš„Gitä»“åº“
    try {
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      const hasGitRepo = fs.existsSync(effectiveLocalPath) && 
                        fs.existsSync(path.join(effectiveLocalPath, '.git'))
      
      if (hasGitRepo) {
        // æœ‰ç°æœ‰ä»“åº“ï¼Œéœ€è¦ç”¨æˆ·æ³¨æ„
        return {
          platformChanged: true,
          needsAttention: true,
          message: `æ£€æµ‹åˆ°Gitå¹³å°å˜æ›´ï¼š${oldConfig.provider || 'æœªçŸ¥'} â†’ ${newConfig.provider}ã€‚\nå»ºè®®ä½¿ç”¨"åˆ‡æ¢Gitå¹³å°"å‘½ä»¤æ¥å¦¥å–„å¤„ç†ç°æœ‰æ•°æ®ã€‚`
        }
      } else {
        // æ²¡æœ‰ç°æœ‰ä»“åº“ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨æ–°é…ç½®
        return {
          platformChanged: true,
          needsAttention: false,
          message: `å·²åˆ‡æ¢åˆ°æ–°çš„Gitå¹³å°ï¼š${newConfig.provider}`
        }
      }
    } catch (error) {
      console.warn('æ£€æŸ¥Gitä»“åº“çŠ¶æ€å¤±è´¥:', error)
      return {
        platformChanged: true,
        needsAttention: true,
        message: 'é…ç½®å·²æ›´æ–°ï¼Œä½†æ— æ³•ç¡®å®šç°æœ‰Gitä»“åº“çŠ¶æ€ã€‚å»ºè®®æ£€æŸ¥åŒæ­¥è®¾ç½®ã€‚'
      }
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å·²é…ç½®GitåŒæ­¥
   */
  public isConfigured(): boolean {
    return !!(
      this.config.provider &&
      this.config.repositoryUrl &&
      (this.config.authenticationMethod === 'ssh' || this.config.token)
    )
    // æ³¨æ„ï¼šä¸å†æ£€æŸ¥ localPathï¼Œå› ä¸ºç³»ç»Ÿä¼šè‡ªåŠ¨æä¾›é»˜è®¤è·¯å¾„
  }

  /**
   * åˆå§‹åŒ–æˆ–æ‰“å¼€æœ¬åœ°Gitä»“åº“
   */
  private async initOrOpenLocalRepo(): Promise<SimpleGit> {
    // è·å–æœ‰æ•ˆçš„æœ¬åœ°è·¯å¾„ï¼Œä¼˜å…ˆä½¿ç”¨é…ç½®çš„è·¯å¾„ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤è·¯å¾„
    const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()

    // Ensure the directory exists
    if (!fs.existsSync(effectiveLocalPath)) {
      fs.mkdirSync(effectiveLocalPath, { recursive: true })
    }

    const git = simpleGit(effectiveLocalPath)

    // Check if it's already a git repository
    const isRepo = await git.checkIsRepo()
    
    if (!isRepo) {
      // console.log('Initializing new Git repository...')
      
      // è·å–ç›®æ ‡åˆ†æ”¯å
      const targetBranch = this.config.defaultBranch || 'main'
      
      // åˆå§‹åŒ–ä»“åº“å¹¶è®¾ç½®é»˜è®¤åˆ†æ”¯
      await git.init()
      
      // å°è¯•è®¾ç½®é»˜è®¤åˆ†æ”¯åï¼ˆå¦‚æœGitç‰ˆæœ¬æ”¯æŒï¼‰
      try {
        await git.raw(['config', 'init.defaultBranch', targetBranch])
        // console.log(`è®¾ç½®é»˜è®¤åˆ†æ”¯ä¸º: ${targetBranch}`)
      } catch (defaultBranchError) {
        console.warn('è®¾ç½®é»˜è®¤åˆ†æ”¯å¤±è´¥ï¼ˆå¯èƒ½æ˜¯Gitç‰ˆæœ¬è¾ƒæ—§ï¼‰:', defaultBranchError)
      }
      
      // Set up user configuration if not set
      try {
        await git.addConfig('user.name', 'StarCode Snippets')
        await git.addConfig('user.email', 'starcode-snippets@local')
      } catch (error) {
        console.warn('Failed to set git user config:', error)
      }
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºåˆå§‹åˆ†æ”¯
      try {
        const branches = await git.branchLocal()
        if (branches.all.length === 0) {
          // console.log(`åˆ›å»ºåˆå§‹åˆ†æ”¯: ${targetBranch}`)
          // åˆ›å»ºä¸€ä¸ªåˆå§‹çš„ç©ºæäº¤æ¥å»ºç«‹åˆ†æ”¯
          try {
            // åˆ›å»ºä¸€ä¸ª.gitkeepæ–‡ä»¶ä»¥ä¾¿æœ‰å†…å®¹å¯æäº¤
            const gitkeepPath = path.join(effectiveLocalPath, '.gitkeep')
            if (!fs.existsSync(gitkeepPath)) {
              fs.writeFileSync(gitkeepPath, '# StarCode Snippets Repository\n')
            }
            
            await git.add('.gitkeep')
            await git.commit('Initial commit for StarCode Snippets')
            
            // å¦‚æœå½“å‰ä¸åœ¨ç›®æ ‡åˆ†æ”¯ï¼Œåˆ›å»ºå¹¶åˆ‡æ¢åˆ°ç›®æ ‡åˆ†æ”¯
            const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD']).catch(() => 'HEAD')
            if (currentBranch !== targetBranch && currentBranch !== 'HEAD') {
              await git.checkoutLocalBranch(targetBranch)
            }
            
            // console.log(`åˆå§‹åˆ†æ”¯ ${targetBranch} åˆ›å»ºæˆåŠŸ`)
          } catch (initialCommitError) {
            console.warn('åˆ›å»ºåˆå§‹æäº¤å¤±è´¥:', initialCommitError)
            // å¦‚æœåˆ›å»ºåˆå§‹æäº¤å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œï¼Œåç»­åŒæ­¥æ—¶ä¼šå¤„ç†
          }
        }
      } catch (branchCheckError) {
        console.warn('æ£€æŸ¥åˆ†æ”¯çŠ¶æ€å¤±è´¥:', branchCheckError)
      }
    } else {
      // console.log('æ‰“å¼€ç°æœ‰Gitä»“åº“...')
      
      // æ£€æŸ¥ç°æœ‰ä»“åº“çš„åˆ†æ”¯çŠ¶æ€
      try {
        const branches = await git.branchLocal()
        const targetBranch = this.config.defaultBranch || 'main'
        
        // console.log(`ç°æœ‰ä»“åº“åˆ†æ”¯: ${branches.all.join(', ')}`)
        // console.log(`ç›®æ ‡åˆ†æ”¯: ${targetBranch}`)
        
        if (branches.all.length > 0) {
          const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD']).catch(() => null)
          // console.log(`å½“å‰åˆ†æ”¯: ${currentBranch}`)
          
          // å¦‚æœç›®æ ‡åˆ†æ”¯ä¸å­˜åœ¨ä½†æœ‰å…¶ä»–åˆ†æ”¯ï¼Œæé†’ç”¨æˆ·
          if (!branches.all.includes(targetBranch) && branches.all.length > 0) {
            console.warn(`è­¦å‘Š: ç›®æ ‡åˆ†æ”¯ ${targetBranch} ä¸å­˜åœ¨ï¼Œå½“å‰åˆ†æ”¯: ${currentBranch}`)
            console.warn('å°†åœ¨åŒæ­¥è¿‡ç¨‹ä¸­å¤„ç†åˆ†æ”¯åˆ‡æ¢')
          }
        }
      } catch (branchInfoError) {
        console.warn('è·å–ç°æœ‰ä»“åº“åˆ†æ”¯ä¿¡æ¯å¤±è´¥:', branchInfoError)
      }
    }

    return git
  }

  /**
   * é…ç½®è¿œç¨‹ä»“åº“
   */
  private async configureRemote(git: SimpleGit): Promise<void> {
    if (!this.config.repositoryUrl) {
      throw new Error('ä»“åº“URLæœªé…ç½®')
    }

    try {
      // Check if origin remote exists
      const remotes = await git.getRemotes(true)
      const originRemote = remotes.find(remote => remote.name === 'origin')

      let remoteUrl = this.config.repositoryUrl

      // å¯¹äºæ‰€æœ‰å¹³å°ï¼Œç»Ÿä¸€ä½¿ç”¨URLåµŒå…¥tokençš„æ–¹å¼
      if (this.config.authenticationMethod === 'token' && this.config.token) {
        remoteUrl = this.embedTokenInUrl(this.config.repositoryUrl, this.config.token)
        // console.log(`é…ç½® ${this.config.provider} è®¤è¯å®Œæˆ`)
      }

      if (originRemote) {
        // Update existing remote if URL is different
        if (originRemote.refs.fetch !== remoteUrl) {
          await git.removeRemote('origin')
          await git.addRemote('origin', remoteUrl)
        }
      } else {
        // Add new remote
        await git.addRemote('origin', remoteUrl)
      }
    } catch (error) {
      throw new Error(`é…ç½®è¿œç¨‹ä»“åº“å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * åœ¨Git URLä¸­åµŒå…¥è®¤è¯ä»¤ç‰Œ
   */
  private embedTokenInUrl(url: string, token: string): string {
    try {
      const urlObj = new URL(url)
      
      // For GitHub, GitLab, and Gitee, use token as username
      if (this.config.provider === 'github') {
        urlObj.username = token
        urlObj.password = 'x-oauth-basic'
      } else if (this.config.provider === 'gitlab') {
        urlObj.username = 'oauth2'
        urlObj.password = token
      } else if (this.config.provider === 'gitee') {
        // Giteeè®¤è¯ï¼šä½¿ç”¨æµ‹è¯•ä¸­éªŒè¯æœ‰æ•ˆçš„oauth2æ–¹å¼
        urlObj.username = 'oauth2'
        urlObj.password = token
      } else {
        // Generic token embedding
        urlObj.username = token
      }
      
      return urlObj.toString()
    } catch (error) {
      console.warn('Failed to embed token in URL, using original URL:', error)
      return url
    }
  }

  /**
   * è·å–æˆ–åˆå§‹åŒ–Gitå®ä¾‹
   */
  private async getGitInstance(): Promise<SimpleGit> {
    if (!this.git) {
      this.git = await this.initOrOpenLocalRepo()
      await this.configureRemote(this.git)
    }
    return this.git
  }

  /**
   * æµ‹è¯•Gitè¿æ¥
   */
  public async testConnection(): Promise<{ success: boolean; message: string }> {
    try {
      if (!this.isConfigured()) {
        return {
          success: false,
          message: 'Git åŒæ­¥é…ç½®ä¸å®Œæ•´',
        }
      }

      // console.log('Testing Git connection...')
      
      // ä¸ºGiteeé…ç½®ç‰¹æ®Šå¤„ç†
      if (this.config.provider === 'gitee' && this.config.authenticationMethod === 'token') {
        // console.log('ä½¿ç”¨Giteeç‰¹æ®Šè®¤è¯æ–¹å¼æµ‹è¯•è¿æ¥...')
        
        try {
          // ä¸ºGiteeä½¿ç”¨ç‰¹æ®Šçš„è¿æ¥æµ‹è¯•æ–¹æ³•
          return await this.testGiteeConnection();
        } catch (giteeError) {
          const errorMessage = giteeError instanceof Error ? giteeError.message : 'æœªçŸ¥é”™è¯¯';
          return {
            success: false,
            message: `Giteeè¿æ¥æµ‹è¯•å¤±è´¥: ${errorMessage}\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦æœ‰æ•ˆ\n2. ç¡®è®¤ä»“åº“åœ°å€æ ¼å¼æ˜¯å¦æ­£ç¡®\n3. å°è¯•ä½¿ç”¨SSHè®¤è¯æ–¹å¼`
          };
        }
      }
      
      const git = await this.getGitInstance()
      
      // é¦–å…ˆæµ‹è¯•è¿œç¨‹ä»“åº“çš„å¯è®¿é—®æ€§
      try {
        await git.listRemote(['--heads', 'origin'])
        // console.log('è¿œç¨‹ä»“åº“å¯è®¿é—®')
        
        // æ£€æŸ¥è¿œç¨‹æ˜¯å¦æœ‰åˆ†æ”¯
        const remoteBranches = await git.listRemote(['--heads', 'origin'])
        if (!remoteBranches || remoteBranches.trim() === '') {
          return {
            success: true,
            message: `æˆåŠŸè¿æ¥åˆ° ${this.config.provider} ä»“åº“ï¼\n\nâš ï¸ æ³¨æ„ï¼šè¿™æ˜¯ä¸€ä¸ªç©ºä»“åº“ï¼ˆæ²¡æœ‰ä»»ä½•åˆ†æ”¯ï¼‰ã€‚\né¦–æ¬¡åŒæ­¥æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ›å»º '${this.config.defaultBranch || 'main'}' åˆ†æ”¯å¹¶æ¨é€æ‚¨çš„ä»£ç ç‰‡æ®µã€‚`,
          }
        }
        
        // ä»“åº“ä¸ä¸ºç©ºï¼Œå°è¯•è·å–æŒ‡å®šåˆ†æ”¯
        const targetBranch = this.config.defaultBranch || 'main'
        try {
          await git.fetch('origin', targetBranch)
          return {
            success: true,
            message: `æˆåŠŸè¿æ¥åˆ° ${this.config.provider} ä»“åº“ï¼\nè¿œç¨‹åˆ†æ”¯ '${targetBranch}' å­˜åœ¨ï¼Œå¯ä»¥è¿›è¡ŒåŒæ­¥ã€‚`,
          }
        } catch (branchError) {
          // åˆ†æ”¯ä¸å­˜åœ¨ï¼Œä½†ä»“åº“å¯è®¿é—®
          const branchErrorMsg = branchError instanceof Error ? branchError.message : 'æœªçŸ¥é”™è¯¯'
          if (branchErrorMsg.includes('couldn\'t find remote ref') || 
              branchErrorMsg.includes('does not exist')) {
            return {
              success: true,
              message: `æˆåŠŸè¿æ¥åˆ° ${this.config.provider} ä»“åº“ï¼\n\nâš ï¸ æ³¨æ„ï¼šè¿œç¨‹åˆ†æ”¯ '${targetBranch}' ä¸å­˜åœ¨ã€‚\né¦–æ¬¡åŒæ­¥æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ›å»ºè¯¥åˆ†æ”¯å¹¶æ¨é€æ‚¨çš„ä»£ç ç‰‡æ®µã€‚`,
            }
          }
          throw branchError
        }
        
      } catch (remoteError) {
        const errorMessage = remoteError instanceof Error ? remoteError.message : 'æœªçŸ¥é”™è¯¯'
        
        // Giteeç‰¹æœ‰çš„é”™è¯¯å¤„ç†
        if (this.config.provider === 'gitee') {
          if (errorMessage.includes('could not read Username')) {
            return {
              success: false,
              message: `Giteeè®¤è¯å¤±è´¥ï¼å¯èƒ½åŸå› ï¼š\nâ€¢ Tokenæ ¼å¼ä¸æ­£ç¡®\nâ€¢ éœ€è¦æä¾›ç”¨æˆ·åå’Œå¯†ç ï¼ˆGiteeç‰¹æ€§ï¼‰\n\nè¯·å°è¯•ï¼š\n1. ç¡®è®¤Tokenæ˜¯å¦æœ‰æ•ˆ\n2. åœ¨Giteeè®¾ç½®ä¸­é‡æ–°ç”ŸæˆToken\n3. å¦‚éœ€ä½¿ç”¨å¯†ç è®¤è¯ï¼Œè¯·é€‰æ‹©SSHè®¤è¯æ–¹å¼`,
            }
          }
        }
        
        // åˆ†æé”™è¯¯ç±»å‹å¹¶æä¾›å…·ä½“çš„è§£å†³å»ºè®®
        if (errorMessage.includes('Authentication failed') || 
            errorMessage.includes('invalid username or password') ||
            errorMessage.includes('bad credentials')) {
          return {
            success: false,
            message: `è®¤è¯å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š\nâ€¢ Token æ˜¯å¦æ­£ç¡®\nâ€¢ Token æ˜¯å¦æœ‰ç›¸åº”çš„ä»“åº“æƒé™\nâ€¢ ä»“åº“URLæ˜¯å¦æ­£ç¡®\n\né”™è¯¯è¯¦æƒ…: ${errorMessage}`,
          }
        }
        
        if (errorMessage.includes('Repository not found') || 
            errorMessage.includes('not found')) {
          return {
            success: false,
            message: `ä»“åº“ä¸å­˜åœ¨ï¼è¯·æ£€æŸ¥ï¼š\nâ€¢ ä»“åº“URLæ˜¯å¦æ­£ç¡®\nâ€¢ ä»“åº“æ˜¯å¦ä¸ºç§æœ‰ï¼ˆéœ€è¦ç›¸åº”æƒé™ï¼‰\nâ€¢ Tokenæ˜¯å¦æœ‰è®¿é—®è¯¥ä»“åº“çš„æƒé™\n\né”™è¯¯è¯¦æƒ…: ${errorMessage}`,
          }
        }
        
        if (errorMessage.includes('Network') || 
            errorMessage.includes('timeout') || 
            errorMessage.includes('connection')) {
          return {
            success: false,
            message: `ç½‘ç»œè¿æ¥å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š\nâ€¢ ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\nâ€¢ æ˜¯å¦éœ€è¦ä»£ç†è®¾ç½®\nâ€¢ é˜²ç«å¢™æ˜¯å¦é˜»æ­¢äº†è¿æ¥\n\né”™è¯¯è¯¦æƒ…: ${errorMessage}`,
          }
        }
        
        return {
          success: false,
          message: `è¿æ¥å¤±è´¥: ${errorMessage}\n\nè¯·æ£€æŸ¥é…ç½®æ˜¯å¦æ­£ç¡®ï¼Œæˆ–æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚`,
        }
      }
    } catch (error) {
      console.error('Git connection test failed:', error)
      return {
        success: false,
        message: `è¿æ¥æµ‹è¯•å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,
      }
    }
  }
  
  /**
   * ä¸“ç”¨äºGiteeçš„è¿æ¥æµ‹è¯•æ–¹æ³•
   * ä½¿ç”¨ç›´æ¥HTTPè¯·æ±‚æ–¹å¼æµ‹è¯•ä»¤ç‰Œæœ‰æ•ˆæ€§å’Œä»“åº“è®¿é—®æƒé™
   */
  private async testGiteeConnection(): Promise<{ success: boolean; message: string }> {
    try {
      if (!this.config.token) {
        return {
          success: false,
          message: 'Giteeéœ€è¦è®¿é—®ä»¤ç‰Œæ‰èƒ½è¿æ¥'
        };
      }
      
      // ä»ä»“åº“URLä¸­æå–æ‰€æœ‰è€…å’Œä»“åº“å
      const repoUrl = this.config.repositoryUrl;
      const urlMatch = repoUrl.match(/gitee\.com\/([\w-]+)\/([\w-]+)(\.git)?$/);
      
      if (!urlMatch) {
        return {
          success: false,
          message: `æ— æ•ˆçš„Giteeä»“åº“URL: ${repoUrl}\n\næ­£ç¡®æ ¼å¼åº”ä¸º: https://gitee.com/ç”¨æˆ·å/ä»“åº“å.git`
        };
      }
      
      const owner = urlMatch[1];
      const repo = urlMatch[2];
      
      // console.log(`å°è¯•ç›´æ¥è®¿é—®Gitee APIéªŒè¯ä»“åº“: ${owner}/${repo}`);
      
      // ä½¿ç”¨Gitee APIæ£€æŸ¥ä»“åº“çŠ¶æ€
      const apiUrl = `https://gitee.com/api/v5/repos/${owner}/${repo}?access_token=${this.config.token}`;
      
      // ä½¿ç”¨Node.jså†…ç½®çš„httpsæ¨¡å—è¿›è¡Œè¯·æ±‚
      const https = require('https');
      const result = await new Promise<{ success: boolean; message: string }>((resolve, reject) => {
        const req = https.get(apiUrl, (res: any) => {
          let data = '';
          
          res.on('data', (chunk: any) => {
            data += chunk;
          });
          
          res.on('end', () => {
            if (res.statusCode === 200) {
              try {
                const repoInfo = JSON.parse(data);
                resolve({
                  success: true,
                  message: `æˆåŠŸè¿æ¥åˆ°Giteeä»“åº“: ${repoInfo.full_name || `${owner}/${repo}`}\n\nä»“åº“æè¿°: ${repoInfo.description || 'æ— æè¿°'}\né»˜è®¤åˆ†æ”¯: ${repoInfo.default_branch || 'master'}`
                });
              } catch (parseError) {
                resolve({
                  success: true,
                  message: `æˆåŠŸè¿æ¥åˆ°Giteeä»“åº“: ${owner}/${repo}\nä½†æ— æ³•è§£æä»“åº“è¯¦æƒ…`
                });
              }
            } else if (res.statusCode === 404) {
              resolve({
                success: false,
                message: `ä»“åº“ä¸å­˜åœ¨æˆ–æ— æƒè®¿é—®: ${owner}/${repo}\n\nè¯·æ£€æŸ¥:\nâ€¢ ä»“åº“URLæ˜¯å¦æ­£ç¡®\nâ€¢ ä»¤ç‰Œæ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥ä»“åº“`
              });
            } else if (res.statusCode === 401 || res.statusCode === 403) {
              resolve({
                success: false,
                message: `Giteeè®¤è¯å¤±è´¥ (${res.statusCode})ã€‚\n\nè¯·æ£€æŸ¥:\nâ€¢ è®¿é—®ä»¤ç‰Œæ˜¯å¦æœ‰æ•ˆ\nâ€¢ ä»¤ç‰Œæ˜¯å¦å…·æœ‰æ­£ç¡®çš„æƒé™\nâ€¢ ä»¤ç‰Œæ˜¯å¦å·²è¿‡æœŸ`
              });
            } else {
              resolve({
                success: false,
                message: `Gitee APIè¿”å›é”™è¯¯: ${res.statusCode}\n\nå“åº”æ•°æ®: ${data}`
              });
            }
          });
        });
        
        req.on('error', (error: any) => {
          reject(new Error(`Gitee APIè¯·æ±‚å¤±è´¥: ${error.message}`));
        });
        
        req.end();
      });
      
      return result;
    } catch (error) {
      console.error('Giteeè¿æ¥æµ‹è¯•å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - æ‹‰å–è¿œç¨‹å˜æ›´
   */
  public async gitPull(branch?: string): Promise<void> {
    const git = await this.getGitInstance()
    const targetBranch = branch || this.config.defaultBranch || 'main'
    
    try {
      // å…ˆæ£€æŸ¥æœ¬åœ°çŠ¶æ€
      const status = await git.status()
      const hasUncommittedChanges = status.files.length > 0
      
      if (hasUncommittedChanges) {
        // console.log('æ£€æµ‹åˆ°æœªæäº¤çš„æœ¬åœ°æ›´æ”¹ï¼Œä½¿ç”¨æ™ºèƒ½åˆå¹¶ç­–ç•¥...')
        
        // æš‚å­˜å½“å‰æ›´æ”¹
        await git.stash(['push', '-m', 'Auto-stash before sync'])
        // console.log('å·²æš‚å­˜æœ¬åœ°æ›´æ”¹')
        
        try {
          // æ‹‰å–è¿œç¨‹æ›´æ”¹
          await git.pull('origin', targetBranch)
          // console.log('è¿œç¨‹æ›´æ”¹æ‹‰å–æˆåŠŸ')
          
          // å°è¯•æ¢å¤æš‚å­˜çš„æ›´æ”¹
          try {
            await git.stash(['pop'])
            // console.log('å·²æ¢å¤æœ¬åœ°æ›´æ”¹')
          } catch (stashPopError) {
            // å¦‚æœæ¢å¤æš‚å­˜æ—¶å‘ç”Ÿå†²çªï¼Œéœ€è¦æ‰‹åŠ¨å¤„ç†
            const stashErrorMsg = stashPopError instanceof Error ? stashPopError.message : 'æœªçŸ¥é”™è¯¯'
            if (stashErrorMsg.includes('conflict') || stashErrorMsg.includes('CONFLICT')) {
              throw new Error(`åˆå¹¶å†²çªï¼šæœ¬åœ°æ›´æ”¹ä¸è¿œç¨‹æ›´æ”¹å­˜åœ¨å†²çªã€‚è¯·æ‰‹åŠ¨è§£å†³å†²çªåé‡æ–°åŒæ­¥ã€‚\n\nè¯¦ç»†ä¿¡æ¯ï¼š${stashErrorMsg}`)
            }
            throw stashPopError
          }
        } catch (pullError) {
          const pullErrorMessage = pullError instanceof Error ? pullError.message : 'æœªçŸ¥é”™è¯¯'
          
          // å¤„ç† "refusing to merge unrelated histories" é”™è¯¯
          if (pullErrorMessage.includes('refusing to merge unrelated histories')) {
            // console.log('æ£€æµ‹åˆ°ä¸ç›¸å…³å†å²é”™è¯¯ï¼Œå°è¯•ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹...')
            
            try {
              // ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹é‡æ–°æ‹‰å–
              await git.pull('origin', targetBranch, ['--allow-unrelated-histories'])
              // console.log('ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹æ‹‰å–æˆåŠŸ')
              
              // æ‹‰å–æˆåŠŸåï¼Œå°è¯•æ¢å¤æš‚å­˜çš„æ›´æ”¹
              try {
                await git.stash(['pop'])
                // console.log('å·²æ¢å¤æœ¬åœ°æ›´æ”¹')
              } catch (stashPopError) {
                const stashErrorMsg = stashPopError instanceof Error ? stashPopError.message : 'æœªçŸ¥é”™è¯¯'
                if (stashErrorMsg.includes('conflict') || stashErrorMsg.includes('CONFLICT')) {
                  throw new Error(`åˆå¹¶å†²çªï¼šæœ¬åœ°æ›´æ”¹ä¸è¿œç¨‹æ›´æ”¹å­˜åœ¨å†²çªã€‚è¯·æ‰‹åŠ¨è§£å†³å†²çªåé‡æ–°åŒæ­¥ã€‚\n\nè¯¦ç»†ä¿¡æ¯ï¼š${stashErrorMsg}`)
                }
                throw stashPopError
              }
              return // æˆåŠŸå¤„ç†ï¼Œé€€å‡ºå‡½æ•°
            } catch (retryError) {
              // å¦‚æœé‡è¯•ä¹Ÿå¤±è´¥ï¼Œæ¢å¤æš‚å­˜çš„æ›´æ”¹
              try {
                await git.stash(['pop'])
                // console.log('é‡è¯•æ‹‰å–å¤±è´¥ï¼Œå·²æ¢å¤æœ¬åœ°æ›´æ”¹')
              } catch (restoreError) {
                console.warn('æ¢å¤æœ¬åœ°æ›´æ”¹å¤±è´¥:', restoreError)
              }
              
                             const retryErrorMessage = retryError instanceof Error ? retryError.message : 'æœªçŸ¥é”™è¯¯'
               
               // è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦é‡æ–°åˆå§‹åŒ–ä»“åº“
               const shouldReinitialize = await vscode.window.showErrorMessage(
                 `Gitå†å²å†²çªæ— æ³•è‡ªåŠ¨è§£å†³ã€‚è¿™é€šå¸¸å‘ç”Ÿåœ¨æœ¬åœ°ä»“åº“å’Œè¿œç¨‹ä»“åº“æœ‰ä¸åŒçš„æäº¤å†å²æ—¶ã€‚\n\nåŸå§‹é”™è¯¯: ${pullErrorMessage}\né‡è¯•é”™è¯¯: ${retryErrorMessage}`,
                 { modal: true },
                 'é‡æ–°åˆå§‹åŒ–ä»“åº“',
                 'å–æ¶ˆ'
               )
               
               if (shouldReinitialize === 'é‡æ–°åˆå§‹åŒ–ä»“åº“') {
                 // console.log('ç”¨æˆ·é€‰æ‹©é‡æ–°åˆå§‹åŒ–ä»“åº“')
                 const reinitResult = await this.reinitializeRepository()
                 
                 if (reinitResult.success) {
                   // é‡æ–°åˆå§‹åŒ–æˆåŠŸï¼Œæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                   vscode.window.showInformationMessage(reinitResult.message)
                   return // æˆåŠŸå¤„ç†ï¼Œé€€å‡ºå‡½æ•°
                 } else {
                   throw new Error(`é‡æ–°åˆå§‹åŒ–å¤±è´¥: ${reinitResult.message}`)
                 }
               } else {
                 throw new Error(`æ‹‰å–è¿œç¨‹å˜æ›´å¤±è´¥: ç”¨æˆ·å–æ¶ˆäº†é‡æ–°åˆå§‹åŒ–æ“ä½œã€‚\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥è¿œç¨‹ä»“åº“æ˜¯å¦æ­£ç¡®\n2. æ‰‹åŠ¨åˆ é™¤æœ¬åœ°ä»“åº“ç›®å½•åé‡æ–°åŒæ­¥\n3. æˆ–è€…è”ç³»æŠ€æœ¯æ”¯æŒ`)
               }
            }
          }
          
          // å¦‚æœä¸æ˜¯ unrelated histories é”™è¯¯ï¼Œæ¢å¤æš‚å­˜çš„æ›´æ”¹å¹¶æŠ›å‡ºåŸå§‹é”™è¯¯
          try {
            await git.stash(['pop'])
            // console.log('æ‹‰å–å¤±è´¥ï¼Œå·²æ¢å¤æœ¬åœ°æ›´æ”¹')
          } catch (restoreError) {
            console.warn('æ¢å¤æœ¬åœ°æ›´æ”¹å¤±è´¥:', restoreError)
          }
          throw pullError
        }
      } else {
        // æ²¡æœ‰æœ¬åœ°æ›´æ”¹ï¼Œç›´æ¥æ‹‰å–
        await git.pull('origin', targetBranch)
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      
      // å¤„ç† "refusing to merge unrelated histories" é”™è¯¯
      if (errorMessage.includes('refusing to merge unrelated histories')) {
        // console.log('æ£€æµ‹åˆ°ä¸ç›¸å…³å†å²é”™è¯¯ï¼Œå°è¯•ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹...')
        
        try {
          // ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹é‡æ–°æ‹‰å–
          await git.pull('origin', targetBranch, ['--allow-unrelated-histories'])
          // console.log('ä½¿ç”¨ --allow-unrelated-histories é€‰é¡¹æ‹‰å–æˆåŠŸ')
          return
        } catch (retryError) {
                     const retryErrorMessage = retryError instanceof Error ? retryError.message : 'æœªçŸ¥é”™è¯¯'
           
           // è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦é‡æ–°åˆå§‹åŒ–ä»“åº“
           const shouldReinitialize = await vscode.window.showErrorMessage(
             `Gitå†å²å†²çªæ— æ³•è‡ªåŠ¨è§£å†³ã€‚è¿™é€šå¸¸å‘ç”Ÿåœ¨æœ¬åœ°ä»“åº“å’Œè¿œç¨‹ä»“åº“æœ‰ä¸åŒçš„æäº¤å†å²æ—¶ã€‚\n\nåŸå§‹é”™è¯¯: ${errorMessage}\né‡è¯•é”™è¯¯: ${retryErrorMessage}`,
             { modal: true },
             'é‡æ–°åˆå§‹åŒ–ä»“åº“',
             'å–æ¶ˆ'
           )
           
           if (shouldReinitialize === 'é‡æ–°åˆå§‹åŒ–ä»“åº“') {
             // console.log('ç”¨æˆ·é€‰æ‹©é‡æ–°åˆå§‹åŒ–ä»“åº“')
             const reinitResult = await this.reinitializeRepository()
             
             if (reinitResult.success) {
               // é‡æ–°åˆå§‹åŒ–æˆåŠŸï¼Œæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
               vscode.window.showInformationMessage(reinitResult.message)
               return // æˆåŠŸå¤„ç†ï¼Œé€€å‡ºå‡½æ•°
             } else {
               throw new Error(`é‡æ–°åˆå§‹åŒ–å¤±è´¥: ${reinitResult.message}`)
             }
           } else {
             throw new Error(`æ‹‰å–è¿œç¨‹å˜æ›´å¤±è´¥: ç”¨æˆ·å–æ¶ˆäº†é‡æ–°åˆå§‹åŒ–æ“ä½œã€‚\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥è¿œç¨‹ä»“åº“æ˜¯å¦æ­£ç¡®\n2. æ‰‹åŠ¨åˆ é™¤æœ¬åœ°ä»“åº“ç›®å½•åé‡æ–°åŒæ­¥\n3. æˆ–è€…è”ç³»æŠ€æœ¯æ”¯æŒ`)
           }
        }
      }
      
      throw new Error(`æ‹‰å–è¿œç¨‹å˜æ›´å¤±è´¥: ${errorMessage}`)
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - æ·»åŠ æ‰€æœ‰å˜æ›´
   */
  public async gitAddAll(): Promise<void> {
    const git = await this.getGitInstance()
    
    try {
      await git.add('.')
    } catch (error) {
      throw new Error(`æ·»åŠ æ–‡ä»¶åˆ°æš‚å­˜åŒºå¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - æäº¤å˜æ›´
   */
  public async gitCommit(message: string): Promise<void> {
    const git = await this.getGitInstance()
    
    try {
      // Check if there are changes to commit
      const status = await git.status()
      if (status.files.length === 0) {
        throw new Error('æ²¡æœ‰å˜æ›´éœ€è¦æäº¤')
      }
      
      await git.commit(message)
    } catch (error) {
      throw new Error(`æäº¤å˜æ›´å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - æ¨é€åˆ°è¿œç¨‹
   */
  public async gitPush(branch?: string): Promise<void> {
    const git = await this.getGitInstance()
    const targetBranch = branch || this.config.defaultBranch || 'main'
    
    try {
      await git.push('origin', targetBranch)
    } catch (error) {
      throw new Error(`æ¨é€åˆ°è¿œç¨‹ä»“åº“å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - è·å–çŠ¶æ€
   */
  public async gitStatus(): Promise<any> {
    const git = await this.getGitInstance()
    
    try {
      return await git.status()
    } catch (error) {
      throw new Error(`è·å–GitçŠ¶æ€å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * æ ¸å¿ƒGitæ“ä½œå°è£… - è·å–è¿œç¨‹å˜æ›´
   */
  public async gitFetch(): Promise<void> {
    const git = await this.getGitInstance()
    
    try {
      await git.fetch()
    } catch (error) {
      throw new Error(`è·å–è¿œç¨‹å˜æ›´å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * é‡æ–°åˆå§‹åŒ–æœ¬åœ°ä»“åº“ä»¥è§£å†³å†å²å†²çª
   * è¿™ä¼šåˆ é™¤æœ¬åœ°Gitå†å²å¹¶é‡æ–°ä»è¿œç¨‹å…‹éš†
   */
  public async reinitializeRepository(): Promise<{ success: boolean; message: string }> {
    try {
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      
      // console.log('å¼€å§‹é‡æ–°åˆå§‹åŒ–æœ¬åœ°ä»“åº“...')
      
      // 1. å¤‡ä»½å½“å‰çš„æ•°æ®æ–‡ä»¶
      const backupDir = path.join(effectiveLocalPath, '.backup-' + Date.now())
      const snippetsFile = path.join(effectiveLocalPath, 'snippets.json')
      const directoriesFile = path.join(effectiveLocalPath, 'directories.json')
      
      let hasBackup = false
      if (fs.existsSync(snippetsFile) || fs.existsSync(directoriesFile)) {
        fs.mkdirSync(backupDir, { recursive: true })
        
        if (fs.existsSync(snippetsFile)) {
          fs.copyFileSync(snippetsFile, path.join(backupDir, 'snippets.json'))
        }
        if (fs.existsSync(directoriesFile)) {
          fs.copyFileSync(directoriesFile, path.join(backupDir, 'directories.json'))
        }
        hasBackup = true
        // console.log(`å·²å¤‡ä»½ç°æœ‰æ•°æ®åˆ°: ${backupDir}`)
      }
      
      // 2. åˆ é™¤ .git ç›®å½•
      const gitDir = path.join(effectiveLocalPath, '.git')
      if (fs.existsSync(gitDir)) {
        await this.deleteDirectory(gitDir)
        // console.log('å·²åˆ é™¤ç°æœ‰Gitå†å²')
      }
      
      // 3. é‡æ–°åˆå§‹åŒ–Gitä»“åº“
      this.git = null // é‡ç½®Gitå®ä¾‹
      const git = await this.getGitInstance() // è¿™ä¼šé‡æ–°åˆå§‹åŒ–ä»“åº“
      
      // 4. å°è¯•ä»è¿œç¨‹æ‹‰å–
      try {
        await git.pull('origin', this.config.defaultBranch || 'main')
        // console.log('æˆåŠŸä»è¿œç¨‹æ‹‰å–æ•°æ®')
        
        // 5. æ¸…ç†å¤‡ä»½ï¼ˆå¦‚æœæ‹‰å–æˆåŠŸï¼‰
        if (hasBackup && fs.existsSync(backupDir)) {
          await this.deleteDirectory(backupDir)
          // console.log('å·²æ¸…ç†å¤‡ä»½æ–‡ä»¶')
        }
        
        return {
          success: true,
          message: 'ä»“åº“é‡æ–°åˆå§‹åŒ–æˆåŠŸï¼Œå·²ä»è¿œç¨‹åŒæ­¥æœ€æ–°æ•°æ®'
        }
      } catch (pullError) {
        // console.log('ä»è¿œç¨‹æ‹‰å–å¤±è´¥ï¼Œæ¢å¤å¤‡ä»½æ•°æ®...')
        
        // 6. å¦‚æœæ‹‰å–å¤±è´¥ï¼Œæ¢å¤å¤‡ä»½æ•°æ®
        if (hasBackup && fs.existsSync(backupDir)) {
          if (fs.existsSync(path.join(backupDir, 'snippets.json'))) {
            fs.copyFileSync(path.join(backupDir, 'snippets.json'), snippetsFile)
          }
          if (fs.existsSync(path.join(backupDir, 'directories.json'))) {
            fs.copyFileSync(path.join(backupDir, 'directories.json'), directoriesFile)
          }
          
          // æäº¤æ¢å¤çš„æ•°æ®
          await git.add('.')
          await git.commit('Restore local data after reinitialize')
          
          await this.deleteDirectory(backupDir)
          // console.log('å·²æ¢å¤å¤‡ä»½æ•°æ®')
        }
        
        return {
          success: true,
          message: 'ä»“åº“é‡æ–°åˆå§‹åŒ–æˆåŠŸï¼Œå·²æ¢å¤æœ¬åœ°æ•°æ®ã€‚å»ºè®®æ‰‹åŠ¨æ£€æŸ¥è¿œç¨‹ä»“åº“é…ç½®ã€‚'
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      console.error('é‡æ–°åˆå§‹åŒ–ä»“åº“å¤±è´¥:', errorMessage)
      
      return {
        success: false,
        message: `é‡æ–°åˆå§‹åŒ–ä»“åº“å¤±è´¥: ${errorMessage}`
      }
    }
  }

  /**
   * é€’å½’åˆ é™¤ç›®å½•
   */
  private async deleteDirectory(dirPath: string): Promise<void> {
    if (fs.existsSync(dirPath)) {
      const files = fs.readdirSync(dirPath)
      
      for (const file of files) {
        const filePath = path.join(dirPath, file)
        const stat = fs.statSync(filePath)
        
        if (stat.isDirectory()) {
          await this.deleteDirectory(filePath)
        } else {
          // åœ¨Windowsä¸Šï¼Œå¯èƒ½éœ€è¦ç§»é™¤åªè¯»å±æ€§
          try {
            fs.chmodSync(filePath, 0o666)
          } catch (chmodError) {
            // å¿½ç•¥æƒé™é”™è¯¯
          }
          fs.unlinkSync(filePath)
        }
      }
      
      fs.rmdirSync(dirPath)
    }
  }

  /**
   * ç”Ÿæˆæäº¤ä¿¡æ¯
   */
  private generateCommitMessage(): string {
    const template = this.config.commitMessageTemplate || 'Sync snippets: {timestamp}'
    const timestamp = new Date().toISOString()
    return template.replace('{timestamp}', timestamp)
  }

  /**
   * è®¡ç®—å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ (Generic, can be kept)
   */
  private calculateHash(content: string): string {
    return crypto.createHash('sha256').update(content, 'utf8').digest('hex')
  }

  /**
   * æ£€æŸ¥ä¸¤ä¸ªä»£ç ç‰‡æ®µæ˜¯å¦æœ‰å†…å®¹å·®å¼‚
   */
  private hasSnippetContentDifference(local: CodeSnippetDeprecatedType, remote: CodeSnippetDeprecatedType): boolean {
    // æ¯”è¾ƒå…³é”®å±æ€§çš„å·®å¼‚
    const localContent = {
      name: local.name || '',
      code: local.code || '',
      category: local.category || '',
      language: local.language || '',
      fileName: local.fileName || '',
      filePath: local.filePath || ''
    }
    
    const remoteContent = {
      name: remote.name || '',
      code: remote.code || '',
      category: remote.category || '',
      language: remote.language || '',
      fileName: remote.fileName || '',
      filePath: remote.filePath || ''
    }
    
    return JSON.stringify(localContent) !== JSON.stringify(remoteContent)
  }

  /**
   * æ£€æŸ¥ä¸¤ä¸ªç›®å½•æ˜¯å¦æœ‰å†…å®¹å·®å¼‚
   */
  private hasDirectoryContentDifference(local: DirectoryDeprecatedType, remote: DirectoryDeprecatedType): boolean {
    // æ¯”è¾ƒå…³é”®å±æ€§çš„å·®å¼‚
    const localContent = {
      name: local.name || '',
      description: (local as any).description || '',
      order: local.order || 0
    }
    
    const remoteContent = {
      name: remote.name || '',
      description: (remote as any).description || '',
      order: remote.order || 0
    }
    
    return JSON.stringify(localContent) !== JSON.stringify(remoteContent)
  }

  /**
   * è§£å†³ä»£ç ç‰‡æ®µå†²çª
   * ä½¿ç”¨åŸºäºæ—¶é—´æˆ³çš„æ™ºèƒ½åˆå¹¶ç­–ç•¥ï¼Œæ”¯æŒå¤æ‚å†²çªçš„ä¸‰è·¯åˆå¹¶
   */
  private resolveSnippetConflict(local: CodeSnippetDeprecatedType, remote: CodeSnippetDeprecatedType): {
    strategy: 'use_local' | 'use_remote' | 'use_newer' | 'auto_merge' | 'manual_merge_required'
    resolved: CodeSnippetDeprecatedType
    needsManualMerge?: boolean
    conflictData?: {
      localContent: string
      remoteContent: string
      mergedContent?: string
    }
  } {
    const localTime = local.createTime || 0
    const remoteTime = remote.createTime || 0
    
    // ç­–ç•¥1: ä¼˜å…ˆä½¿ç”¨æœ‰å†…å®¹çš„ç‰ˆæœ¬ï¼ˆéç©ºä»£ç ï¼‰
    const localHasCode = (local.code || '').trim().length > 0
    const remoteHasCode = (remote.code || '').trim().length > 0
    
    if (localHasCode && !remoteHasCode) {
      return { strategy: 'use_local', resolved: local }
    }
    
    if (!localHasCode && remoteHasCode) {
      // ä½¿ç”¨è¿œç¨‹å†…å®¹ï¼ˆV2ç‰ˆæœ¬ä¸éœ€è¦ä¿ç•™IDï¼‰
      return { strategy: 'use_remote', resolved: remote }
    }
    
    // ç­–ç•¥2: å¦‚æœéƒ½æœ‰ä»£ç å†…å®¹ï¼Œå°è¯•æ™ºèƒ½åˆå¹¶
    if (localHasCode && remoteHasCode) {
      const localCode = local.code || ''
      const remoteCode = remote.code || ''
      
      // å¦‚æœä»£ç å®Œå…¨ç›¸åŒï¼Œåªæ˜¯å…¶ä»–å±æ€§ä¸åŒï¼Œä½¿ç”¨è¾ƒæ–°çš„ç‰ˆæœ¬
      if (localCode === remoteCode) {
        if (remoteTime > localTime) {
          // ä½¿ç”¨è¿œç¨‹å†…å®¹ä½†ä¿ç•™æœ¬åœ°ID
          const resolvedSnippet: CodeSnippetDeprecatedType = {
            ...remote,
            id: local.id // ä¿ç•™æœ¬åœ°IDä»¥ç¡®ä¿æ›´æ–°æ“ä½œæ­£å¸¸
          }
          return { strategy: 'use_newer', resolved: resolvedSnippet }
        } else {
          return { strategy: 'use_newer', resolved: local }
        }
      }
      
      // å°è¯•è‡ªåŠ¨åˆå¹¶ä»£ç å†…å®¹
      const mergeResult = this.attemptCodeMerge(localCode, remoteCode)
      
      if (mergeResult.success && mergeResult.merged) {
        // è‡ªåŠ¨åˆå¹¶æˆåŠŸï¼Œåˆ›å»ºåˆå¹¶åçš„ä»£ç ç‰‡æ®µ
        const mergedSnippet: CodeSnippetDeprecatedType = {
          ...remote, // ä½¿ç”¨è¿œç¨‹çš„å…¶ä»–å±æ€§
          code: mergeResult.merged,
          createTime: Math.max(localTime, remoteTime) // ä½¿ç”¨è¾ƒæ–°çš„æ—¶é—´æˆ³
        }
        
        return {
          strategy: 'auto_merge',
          resolved: mergedSnippet
        }
      } else {
        // è‡ªåŠ¨åˆå¹¶å¤±è´¥ï¼Œéœ€è¦æ‰‹åŠ¨åˆå¹¶
        const tempResolved = remoteTime > localTime ? remote : local
        
        return {
          strategy: 'manual_merge_required',
          resolved: tempResolved,
          needsManualMerge: true,
          conflictData: {
            localContent: localCode,
            remoteContent: remoteCode
          }
        }
      }
    }
    
    // ç­–ç•¥3: å¦‚æœéƒ½æ²¡æœ‰å†…å®¹æˆ–å…¶ä»–æƒ…å†µï¼Œä½¿ç”¨æ—¶é—´æˆ³è¾ƒæ–°çš„ç‰ˆæœ¬
    if (remoteTime > localTime) {
      // ä½¿ç”¨è¿œç¨‹å†…å®¹ï¼ˆV2ç‰ˆæœ¬ä¸éœ€è¦ä¿ç•™IDï¼‰
      return { strategy: 'use_newer', resolved: remote }
    } else if (localTime > remoteTime) {
      return { strategy: 'use_newer', resolved: local }
    }
    
    // ç­–ç•¥4: æ—¶é—´æˆ³ç›¸åŒæ—¶ï¼Œä¼˜å…ˆä¿ç•™æœ¬åœ°ç‰ˆæœ¬ï¼ˆä¿å®ˆç­–ç•¥ï¼‰
    return { strategy: 'use_local', resolved: local }
  }

  /**
   * å°è¯•è‡ªåŠ¨åˆå¹¶ä»£ç å†…å®¹
   * ä½¿ç”¨ä¸‰è·¯åˆå¹¶ç®—æ³•å¤„ç†ä»£ç å†²çª
   */
  private attemptCodeMerge(localCode: string, remoteCode: string): {
    success: boolean
    merged?: string
    hasConflicts?: boolean
  } {
    try {
      // ç®€å•æƒ…å†µï¼šå¦‚æœä¸€æ–¹åŒ…å«å¦ä¸€æ–¹çš„å†…å®¹ï¼Œå¯ä»¥å®‰å…¨åˆå¹¶
      if (localCode.includes(remoteCode)) {
        return { success: true, merged: localCode }
      }
      
      if (remoteCode.includes(localCode)) {
        return { success: true, merged: remoteCode }
      }
      
      // ä½¿ç”¨è¡Œçº§diffæ£€æŸ¥å†²çªå¤æ‚åº¦
      const lineDiff = diffLines(localCode, remoteCode)
      const conflictLines = lineDiff.filter(change => change.added || change.removed)
      
      // å¦‚æœå†²çªè¾ƒå°‘ä¸”æ²¡æœ‰é‡å ä¿®æ”¹ï¼Œå°è¯•ç®€å•åˆå¹¶
      if (conflictLines.length <= 5) {
        // å¯¹äºç®€å•çš„æ·»åŠ æ“ä½œï¼Œå¯ä»¥å°è¯•åˆå¹¶
        const hasOnlyAdditions = lineDiff.every(change => !change.removed || change.value.trim() === '')
        
        if (hasOnlyAdditions) {
          // ç®€å•çš„æ·»åŠ æ“ä½œï¼Œåˆå¹¶å†…å®¹
          let merged = localCode
          for (const change of lineDiff) {
            if (change.added && change.value.trim()) {
              merged += '\n' + change.value
            }
          }
          return { success: true, merged: merged.trim() }
        }
      }
      
      // å¤æ‚å†²çªï¼Œéœ€è¦æ‰‹åŠ¨å¤„ç†
      return { success: false, hasConflicts: true }
      
    } catch (error) {
      console.warn('è‡ªåŠ¨åˆå¹¶å¤±è´¥:', error)
      return { success: false }
    }
  }

  /**
   * è§£å†³ç›®å½•å†²çª
   * ä¸»è¦åŸºäºæ—¶é—´æˆ³ï¼Œä½†ä¼šä¿ç•™æœ‰ç”¨çš„æè¿°ä¿¡æ¯
   */
  private resolveDirectoryConflict(local: DirectoryDeprecatedType, remote: DirectoryDeprecatedType): {
    strategy: 'use_local' | 'use_remote' | 'use_newer'
    resolved: DirectoryDeprecatedType
  } {
    const localTime = (local as any).createTime || 0
    const remoteTime = (remote as any).createTime || 0
    
    // ç­–ç•¥: ä½¿ç”¨æ—¶é—´æˆ³è¾ƒæ–°çš„ç‰ˆæœ¬
    if (remoteTime > localTime) {
      // ä½¿ç”¨è¿œç¨‹å†…å®¹ï¼ˆV2ç‰ˆæœ¬ä¸éœ€è¦ä¿ç•™IDï¼‰
      return { strategy: 'use_newer', resolved: remote }
    } else if (localTime > remoteTime) {
      return { strategy: 'use_newer', resolved: local }
    }
    
    // æ—¶é—´æˆ³ç›¸åŒæ—¶ï¼Œä¿ç•™æœ¬åœ°ç‰ˆæœ¬
    return { strategy: 'use_local', resolved: local }
  }

  /**
   * å¤„ç†éœ€è¦æ‰‹åŠ¨åˆå¹¶çš„å†²çª
   * ä¸ºæ¯ä¸ªå†²çªåˆ›å»ºä¸´æ—¶æ–‡ä»¶å¹¶æ‰“å¼€VSCodeçš„åˆå¹¶ç¼–è¾‘å™¨
   */
  private async handleManualMergeConflicts(
    snippetConflicts: Array<any>,
    directoryConflicts: Array<any>
  ): Promise<{
    success: boolean
    message: string
    conflictCount: number
    conflictFiles: string[]
    resolvedSnippets?: CodeSnippetDeprecatedType[]
  }> {
    const allConflicts = [...snippetConflicts, ...directoryConflicts]
    const conflictCount = allConflicts.length
    
    if (conflictCount === 0) {
      return {
        success: true,
        message: 'æ²¡æœ‰éœ€è¦æ‰‹åŠ¨è§£å†³çš„å†²çª',
        conflictCount: 0,
        conflictFiles: []
      }
    }

    try {
      // ä¸ºæ¯ä¸ªå†²çªåˆ›å»ºä¸´æ—¶åˆå¹¶æ–‡ä»¶
      const tempDir = path.join(SettingsManager.getEffectiveLocalPath(), '.merge-conflicts')
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true })
      }

      const conflictFiles: string[] = []
      const conflictFileMapping: Map<string, any> = new Map() // æ˜ å°„å†²çªæ–‡ä»¶è·¯å¾„åˆ°å†²çªå¯¹è±¡

      // å¤„ç†ä»£ç ç‰‡æ®µå†²çª
      for (let i = 0; i < snippetConflicts.length; i++) {
        const conflict = snippetConflicts[i]
        if (!conflict.conflictData) continue

        const conflictFileName = `conflict_${i + 1}_${conflict.fullPath.replace(/[\/\\]/g, '_')}.txt`
        const conflictFilePath = path.join(tempDir, conflictFileName)

        // åˆ›å»ºå†²çªæ–‡ä»¶å†…å®¹ï¼ˆä½¿ç”¨æ ‡å‡†çš„Gitå†²çªæ ‡è®°ï¼‰
        const conflictContent = this.createConflictFileContent(
          conflict.conflictData.localContent,
          conflict.conflictData.remoteContent,
          conflict.fullPath
        )

        fs.writeFileSync(conflictFilePath, conflictContent, 'utf8')
        conflictFiles.push(conflictFilePath)
        conflictFileMapping.set(conflictFilePath, conflict)
      }

      if (conflictFiles.length === 0) {
        return {
          success: true,
          message: 'æ‰€æœ‰å†²çªéƒ½å·²è‡ªåŠ¨è§£å†³',
          conflictCount: 0,
          conflictFiles: []
        }
      }

      // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å·²è§£å†³çš„å†²çªæ–‡ä»¶
      const resolvedConflicts = await this.checkForResolvedConflicts(tempDir, conflictFileMapping)
      
      if (resolvedConflicts.hasResolved) {
        // ç”¨æˆ·å·²ç»æ‰‹åŠ¨è§£å†³äº†å†²çªï¼Œè¯»å–è§£å†³åçš„å†…å®¹
        const resolvedSnippets: CodeSnippetDeprecatedType[] = []
        
        for (const resolvedFile of resolvedConflicts.resolvedFiles) {
          const conflict = conflictFileMapping.get(resolvedFile.filePath)
          if (conflict) {
            // åˆ›å»ºè§£å†³åçš„ä»£ç ç‰‡æ®µå¯¹è±¡
            const resolvedSnippet: CodeSnippetDeprecatedType = {
              ...conflict.remote, // ä½¿ç”¨è¿œç¨‹çš„åŸºç¡€ç»“æ„
              code: resolvedFile.resolvedContent, // ä½¿ç”¨ç”¨æˆ·è§£å†³åçš„ä»£ç å†…å®¹
              createTime: Math.max(conflict.local.createTime || 0, conflict.remote.createTime || 0) // ä½¿ç”¨è¾ƒæ–°çš„æ—¶é—´æˆ³
            }
            resolvedSnippets.push(resolvedSnippet)
          }
        }
        
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        await this.cleanupTempConflictFiles(tempDir)
        
        return {
          success: true,
          message: `å·²è¯»å–ç”¨æˆ·æ‰‹åŠ¨è§£å†³çš„ ${resolvedConflicts.resolvedFiles.length} ä¸ªå†²çª`,
          conflictCount,
          conflictFiles: [],
          resolvedSnippets
        }
      }

      // è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦æ‰“å¼€åˆå¹¶ç¼–è¾‘å™¨
      const choice = await vscode.window.showWarningMessage(
        `æ£€æµ‹åˆ° ${conflictCount} ä¸ªéœ€è¦æ‰‹åŠ¨è§£å†³çš„ä»£ç å†²çªã€‚\n\nç³»ç»Ÿå·²ç»ä¸ºæ¯ä¸ªå†²çªåˆ›å»ºäº†ä¸´æ—¶æ–‡ä»¶ï¼Œæ‚¨å¯ä»¥ï¼š\n1. æ‰“å¼€å†²çªæ–‡ä»¶æ‰‹åŠ¨ç¼–è¾‘\n2. ä½¿ç”¨è‡ªåŠ¨è§£å†³æ–¹æ¡ˆï¼ˆä¿ç•™è¾ƒæ–°ç‰ˆæœ¬ï¼‰\n3. å–æ¶ˆåŒæ­¥`,
        { modal: true },
        'æ‰“å¼€å†²çªæ–‡ä»¶',
        'è‡ªåŠ¨è§£å†³ï¼ˆä¿ç•™è¾ƒæ–°ç‰ˆæœ¬ï¼‰',
        'å–æ¶ˆåŒæ­¥'
      )

      if (choice === 'å–æ¶ˆåŒæ­¥') {
        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        await this.cleanupTempConflictFiles(tempDir)
        return {
          success: false,
          message: 'ç”¨æˆ·å–æ¶ˆäº†åŒæ­¥æ“ä½œ',
          conflictCount,
          conflictFiles: []
        }
      }

      if (choice === 'è‡ªåŠ¨è§£å†³ï¼ˆä¿ç•™è¾ƒæ–°ç‰ˆæœ¬ï¼‰') {
        // ä½¿ç”¨è‡ªåŠ¨è§£å†³ç­–ç•¥
        const resolvedSnippets: CodeSnippetDeprecatedType[] = []
        for (const conflict of snippetConflicts) {
          if (conflict.conflictData) {
            // åŸºäºæ—¶é—´æˆ³é€‰æ‹©ç‰ˆæœ¬
            const localTime = conflict.local.createTime || 0
            const remoteTime = conflict.remote.createTime || 0
            const resolved = remoteTime > localTime ? conflict.remote : conflict.local
            resolvedSnippets.push(resolved)
          }
        }

        // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        await this.cleanupTempConflictFiles(tempDir)

        return {
          success: true,
          message: `å·²è‡ªåŠ¨è§£å†³ ${conflictCount} ä¸ªå†²çªï¼ˆä¿ç•™è¾ƒæ–°ç‰ˆæœ¬ï¼‰`,
          conflictCount,
          conflictFiles: [],
          resolvedSnippets
        }
      }

      if (choice === 'æ‰“å¼€å†²çªæ–‡ä»¶') {
        // è®¾ç½®æ–‡ä»¶ç›‘å¬å™¨ï¼Œå½“ç”¨æˆ·ä¿å­˜å†²çªæ–‡ä»¶æ—¶è‡ªåŠ¨æ£€æŸ¥æ˜¯å¦å·²è§£å†³
        this.setupConflictFileWatcher(tempDir, conflictFileMapping)
        
        // æ‰“å¼€ç¬¬ä¸€ä¸ªå†²çªæ–‡ä»¶
        if (conflictFiles.length > 0) {
          const document = await vscode.workspace.openTextDocument(conflictFiles[0])
          await vscode.window.showTextDocument(document)
          
          // æ˜¾ç¤ºæŒ‡å¼•æ¶ˆæ¯ - é€šè¿‡é€šçŸ¥æ–¹å¼
          vscode.window.showInformationMessage(
            `ğŸ”€ å†²çªè§£å†³æŒ‡å—ï¼š\n\n1. ä¿ç•™æ‚¨æƒ³è¦çš„å†…å®¹\n2. åˆ é™¤ä¸éœ€è¦çš„å†…å®¹å’Œå†²çªæ ‡è®°è¡Œï¼ˆ<<<<<<< ======= >>>>>>>ï¼‰\n3. ä¿å­˜æ–‡ä»¶ - ç³»ç»Ÿå°†è‡ªåŠ¨æ£€æµ‹å¹¶åº”ç”¨æ‚¨çš„è§£å†³æ–¹æ¡ˆ\n\nğŸ’¡ å¦‚æœæœ‰å¤šä¸ªå†²çªæ–‡ä»¶ï¼Œè§£å†³å½“å‰æ–‡ä»¶åä¼šè‡ªåŠ¨æ‰“å¼€ä¸‹ä¸€ä¸ª`,
            { modal: false },
            'äº†è§£'
          )
          
          // æ˜¾ç¤ºé¢å¤–çš„çŠ¶æ€æ ä¿¡æ¯
          vscode.window.setStatusBarMessage(
            `ğŸ“ æ­£åœ¨è§£å†³å†²çª ${1}/${conflictFiles.length} - ä¿å­˜æ–‡ä»¶åè‡ªåŠ¨åº”ç”¨è§£å†³æ–¹æ¡ˆ`,
            10000
          )
        }

        return {
          success: false,
          message: `è¯·æ‰‹åŠ¨è§£å†³ ${conflictCount} ä¸ªå†²çªæ–‡ä»¶ä¸­çš„å†²çªã€‚ç³»ç»Ÿå·²è®¾ç½®è‡ªåŠ¨ç›‘å¬ï¼Œä¿å­˜æ–‡ä»¶åå°†è‡ªåŠ¨åº”ç”¨è§£å†³æ–¹æ¡ˆã€‚`,
          conflictCount,
          conflictFiles
        }
      }

      // é»˜è®¤è¿”å›å¤±è´¥
      return {
        success: false,
        message: 'æœªé€‰æ‹©å†²çªè§£å†³æ–¹æ¡ˆ',
        conflictCount,
        conflictFiles: []
      }

    } catch (error) {
      console.error('å¤„ç†æ‰‹åŠ¨åˆå¹¶å†²çªå¤±è´¥:', error)
      return {
        success: false,
        message: `å¤„ç†å†²çªå¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,
        conflictCount,
        conflictFiles: []
      }
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å­˜åœ¨å·²è§£å†³çš„å†²çªæ–‡ä»¶
   * è¯»å–ç”¨æˆ·æ‰‹åŠ¨ç¼–è¾‘åçš„å†²çªæ–‡ä»¶å†…å®¹
   */
  private async checkForResolvedConflicts(
    tempDir: string, 
    conflictFileMapping: Map<string, any>
  ): Promise<{
    hasResolved: boolean
    resolvedFiles: Array<{
      filePath: string
      resolvedContent: string
      originalConflict: any
    }>
  }> {
    const resolvedFiles: Array<any> = []
    
    try {
      if (!fs.existsSync(tempDir)) {
        return { hasResolved: false, resolvedFiles: [] }
      }
      
      for (const [filePath, conflict] of conflictFileMapping.entries()) {
        if (fs.existsSync(filePath)) {
          const fileContent = fs.readFileSync(filePath, 'utf8')
          
          // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²ç»è¢«ç”¨æˆ·ç¼–è¾‘ï¼ˆä¸åŒ…å«å†²çªæ ‡è®°ï¼‰
          const hasConflictMarkers = fileContent.includes('<<<<<<< LOCAL') || 
                                   fileContent.includes('=======') || 
                                   fileContent.includes('>>>>>>> REMOTE')
          
          if (!hasConflictMarkers) {
            // ç”¨æˆ·å·²ç»è§£å†³äº†å†²çªï¼Œæå–è§£å†³åçš„ä»£ç å†…å®¹
            const resolvedResult = this.extractResolvedContent(fileContent)
            
                          if (resolvedResult.success && resolvedResult.content.length > 0) {
                resolvedFiles.push({
                  filePath,
                  resolvedContent: resolvedResult.content,
                  originalConflict: conflict
                })
            }
          }
        }
      }
      
      return {
        hasResolved: resolvedFiles.length > 0,
        resolvedFiles
      }
    } catch (error) {
      console.warn('æ£€æŸ¥å·²è§£å†³å†²çªæ–‡ä»¶å¤±è´¥:', error)
      return { hasResolved: false, resolvedFiles: [] }
    }
  }

  /**
   * ä»ç”¨æˆ·ç¼–è¾‘åçš„å†²çªæ–‡ä»¶ä¸­æå–è§£å†³åçš„ä»£ç å†…å®¹
   * æ”¯æŒå¤šé‡å†²çªçš„å¤æ‚è§£æå’ŒéªŒè¯
   */
  private extractResolvedContent(fileContent: string): {
    success: boolean
    content: string
    errors: string[]
  } {
    const errors: string[] = []
    
    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æœªè§£å†³çš„å†²çªæ ‡è®°
    const conflictMarkers = {
      start: /<<<<<<< /g,
      separator: /=======/g,
      end: />>>>>>> /g
    }
    
    const startMatches = Array.from(fileContent.matchAll(conflictMarkers.start))
    const separatorMatches = Array.from(fileContent.matchAll(conflictMarkers.separator))
    const endMatches = Array.from(fileContent.matchAll(conflictMarkers.end))
    
    // éªŒè¯å†²çªæ ‡è®°çš„å®Œæ•´æ€§
    if (startMatches.length !== endMatches.length) {
      errors.push(`å†²çªæ ‡è®°ä¸åŒ¹é…ï¼šæ‰¾åˆ° ${startMatches.length} ä¸ªèµ·å§‹æ ‡è®°ï¼Œä½†åªæœ‰ ${endMatches.length} ä¸ªç»“æŸæ ‡è®°`)
    }
    
    if (separatorMatches.length !== startMatches.length) {
      errors.push(`åˆ†éš”ç¬¦æ•°é‡ä¸åŒ¹é…ï¼šåº”è¯¥æœ‰ ${startMatches.length} ä¸ªåˆ†éš”ç¬¦ï¼Œä½†åªæ‰¾åˆ° ${separatorMatches.length} ä¸ª`)
    }
    
    // å¦‚æœè¿˜æœ‰å†²çªæ ‡è®°ï¼Œè¯´æ˜ç”¨æˆ·æ²¡æœ‰å®Œå…¨è§£å†³å†²çª
    if (startMatches.length > 0) {
      errors.push(`å‘ç° ${startMatches.length} ä¸ªæœªè§£å†³çš„å†²çªåŒºåŸŸï¼Œè¯·åˆ é™¤æ‰€æœ‰å†²çªæ ‡è®°å¹¶ä¿ç•™æ‚¨æƒ³è¦çš„å†…å®¹`)
      
      // æä¾›å…·ä½“çš„å†²çªä½ç½®ä¿¡æ¯
      startMatches.forEach((match, index) => {
        const lineNumber = fileContent.substring(0, match.index).split('\n').length
        errors.push(`  - å†²çªåŒºåŸŸ ${index + 1} åœ¨ç¬¬ ${lineNumber} è¡Œ`)
      })
      
      return {
        success: false,
        content: '',
        errors
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å­¤ç«‹çš„å†²çªæ ‡è®°
    const isolatedMarkers = [
      ...Array.from(fileContent.matchAll(/^=======\s*$/gm)),
      ...Array.from(fileContent.matchAll(/^<<<<<<< /gm)),
      ...Array.from(fileContent.matchAll(/^>>>>>>> /gm))
    ]
    
    if (isolatedMarkers.length > 0) {
      errors.push(`å‘ç° ${isolatedMarkers.length} ä¸ªå­¤ç«‹çš„å†²çªæ ‡è®°ï¼Œè¯·æ£€æŸ¥å¹¶åˆ é™¤æ‰€æœ‰å†²çªç›¸å…³çš„æ ‡è®°`)
      return {
        success: false,
        content: '',
        errors
      }
    }
    
    // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºç©º
    const content = fileContent.trim()
    if (content.length === 0) {
      errors.push('è§£å†³åçš„å†…å®¹ä¸ºç©ºï¼Œè¿™å¯èƒ½ä¸æ˜¯æ‚¨æœŸæœ›çš„ç»“æœ')
      return {
        success: false,
        content: '',
        errors
      }
    }
    
    return {
      success: true,
      content,
      errors: []
    }
  }

  /**
   * åˆ›å»ºå†²çªæ–‡ä»¶å†…å®¹
   * ä½¿ç”¨æ ‡å‡†çš„Gitå†²çªæ ‡è®°æ ¼å¼ï¼Œæ”¯æŒå¤šé‡å†²çªæ£€æµ‹
   */
  private createConflictFileContent(localContent: string, remoteContent: string, filePath: string): string {
    // ä¸ºäº†æ”¯æŒå¤šé‡å†²çªæ£€æµ‹ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ å”¯ä¸€æ ‡è¯†ç¬¦
    const conflictId = require('crypto').randomBytes(4).toString('hex')
    
    return `<<<<<<< LOCAL (å½“å‰è®¾å¤‡çš„ç‰ˆæœ¬) [${conflictId}]
${localContent}
=======
${remoteContent}
>>>>>>> REMOTE (è¿œç¨‹è®¾å¤‡çš„ç‰ˆæœ¬) [${conflictId}]`
  }

  /**
   * æ¸…ç†ä¸´æ—¶å†²çªæ–‡ä»¶
   */
  private async cleanupTempConflictFiles(tempDir: string): Promise<void> {
    try {
      if (fs.existsSync(tempDir)) {
        await this.deleteDirectory(tempDir)
        // console.log('å·²æ¸…ç†ä¸´æ—¶å†²çªæ–‡ä»¶ç›®å½•')
      }
    } catch (error) {
      console.warn('æ¸…ç†ä¸´æ—¶å†²çªæ–‡ä»¶å¤±è´¥:', error)
    }
  }

  /**
   * æ¸…ç†æ‰€æœ‰æ—§çš„ä¸´æ—¶å†²çªæ–‡ä»¶ï¼ˆåœ¨åŒæ­¥å¼€å§‹å‰è°ƒç”¨ï¼‰
   */
  private async cleanupOldConflictFiles(): Promise<void> {
    try {
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      const tempDir = path.join(effectiveLocalPath, '.merge-conflicts')
      
      if (fs.existsSync(tempDir)) {
        // åˆ é™¤æ•´ä¸ªä¸´æ—¶ç›®å½•ï¼Œç¡®ä¿æ²¡æœ‰æ®‹ç•™çš„å†²çªæ–‡ä»¶
        await this.deleteDirectory(tempDir)
        // console.log('å·²æ¸…ç†æ—§çš„ä¸´æ—¶å†²çªæ–‡ä»¶')
      }
    } catch (error) {
      console.warn('æ¸…ç†æ—§ä¸´æ—¶å†²çªæ–‡ä»¶å¤±è´¥:', error)
    }
  }

  /**
   * è®¾ç½®å†²çªæ–‡ä»¶ç›‘å¬å™¨
   * å½“ç”¨æˆ·ä¿å­˜å†²çªæ–‡ä»¶æ—¶è‡ªåŠ¨æ£€æŸ¥æ˜¯å¦å·²è§£å†³å†²çª
   */
  private setupConflictFileWatcher(
    tempDir: string, 
    conflictFileMapping: Map<string, any>
  ): void {
    if (!this.context) {
      console.warn('æ— æ³•è®¾ç½®æ–‡ä»¶ç›‘å¬å™¨ï¼šcontextæœªåˆå§‹åŒ–')
      return
    }

    try {
      // åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿç›‘å¬å™¨
      const pattern = new vscode.RelativePattern(tempDir, '*.txt')
      const watcher = vscode.workspace.createFileSystemWatcher(pattern)
      
      // ç›‘å¬æ–‡ä»¶ä¿å­˜äº‹ä»¶
      const onFileChanged = async (uri: vscode.Uri) => {
        try {
          // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ˜¯å†²çªæ–‡ä»¶
          if (!conflictFileMapping.has(uri.fsPath)) {
            return
          }
          
          // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ï¼Œç¡®ä¿æ–‡ä»¶å·²å®Œå…¨ä¿å­˜
          setTimeout(async () => {
            await this.handleConflictFileChange(uri.fsPath, conflictFileMapping, tempDir)
          }, 500)
        } catch (error) {
          console.error('å¤„ç†å†²çªæ–‡ä»¶å˜æ›´å¤±è´¥:', error)
        }
      }
      
      watcher.onDidChange(onFileChanged)
      watcher.onDidCreate(onFileChanged)
      
      // ç¡®ä¿åœ¨é€‚å½“çš„æ—¶å€™æ¸…ç†ç›‘å¬å™¨
      const disposable = vscode.Disposable.from(watcher)
      this.context.subscriptions.push(disposable)
      
      // è®¾ç½®æ¸…ç†å®šæ—¶å™¨ï¼ˆ30åˆ†é’Ÿåè‡ªåŠ¨æ¸…ç†ï¼‰
      setTimeout(() => {
        try {
          disposable.dispose()
        } catch (error) {
          console.warn('æ¸…ç†æ–‡ä»¶ç›‘å¬å™¨å¤±è´¥:', error)
        }
      }, 30 * 60 * 1000) // 30åˆ†é’Ÿ
      
    } catch (error) {
      console.error('è®¾ç½®å†²çªæ–‡ä»¶ç›‘å¬å™¨å¤±è´¥:', error)
    }
  }

  /**
   * å¤„ç†å†²çªæ–‡ä»¶å˜æ›´äº‹ä»¶
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²è§£å†³å†²çªï¼Œå¦‚æœæ˜¯åˆ™è‡ªåŠ¨åº”ç”¨
   */
  private async handleConflictFileChange(
    filePath: string, 
    conflictFileMapping: Map<string, any>,
    tempDir: string
  ): Promise<void> {
    try {
      if (!fs.existsSync(filePath)) {
        return
      }
      
      const fileContent = fs.readFileSync(filePath, 'utf8')
      
      // ä½¿ç”¨æ–°çš„å†²çªè§£ææ–¹æ³•è¿›è¡Œæ›´robustçš„æ£€æµ‹
      const resolvedResult = this.extractResolvedContent(fileContent)
      
              if (resolvedResult.success) {
          // ç”¨æˆ·å·²ç»è§£å†³äº†å†²çª
          const conflict = conflictFileMapping.get(filePath)
          if (!conflict) {
            return
          }
          
          if (resolvedResult.content.length > 0) {
          // æ˜¾ç¤ºè§£å†³æˆåŠŸçš„é€šçŸ¥
          vscode.window.showInformationMessage(
            `âœ… å†²çªå·²è§£å†³ï¼š${conflict.fullPath}\n\næ­£åœ¨è‡ªåŠ¨åº”ç”¨è§£å†³æ–¹æ¡ˆ...`,
            { modal: false }
          )
          
          // æ›´æ–°çŠ¶æ€æ 
          vscode.window.setStatusBarMessage(
            `âœ… è‡ªåŠ¨åº”ç”¨å†²çªè§£å†³æ–¹æ¡ˆï¼š${path.basename(conflict.fullPath)}`,
            5000
          )
          
          // åº”ç”¨è§£å†³æ–¹æ¡ˆåˆ°VSCodeå­˜å‚¨
          if (this.storageManager) {
            try {
              const resolvedSnippet = {
                id: require('crypto').randomUUID(),
                fullPath: conflict.fullPath,
                name: path.basename(conflict.fullPath),
                code: resolvedResult.content,
                language: '',
                category: path.dirname(conflict.fullPath) === '.' ? '' : path.dirname(conflict.fullPath),
                createTime: Date.now()
              } as any
              
              await this.storageManager.saveSnippet(resolvedSnippet)
              
              // æ¸…é™¤ç¼“å­˜å¹¶åˆ·æ–°ç•Œé¢
              if (this.storageManager.clearCache) {
                this.storageManager.clearCache()
              }
              
              if (this.context) {
                await vscode.commands.executeCommand('starcode-snippets.refreshExplorer')
              }
              
              // ä»æ˜ å°„ä¸­ç§»é™¤å·²è§£å†³çš„å†²çª
              conflictFileMapping.delete(filePath)
              
              // åˆ é™¤å·²è§£å†³çš„å†²çªæ–‡ä»¶
              fs.unlinkSync(filePath)
              
              // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–å†²çªéœ€è¦è§£å†³
              const remainingConflicts = Array.from(conflictFileMapping.keys()).filter(f => fs.existsSync(f))
              
              if (remainingConflicts.length > 0) {
                // è¿˜æœ‰å…¶ä»–å†²çªï¼Œæ‰“å¼€ä¸‹ä¸€ä¸ª
                setTimeout(async () => {
                  try {
                    const nextFile = remainingConflicts[0]
                    const document = await vscode.workspace.openTextDocument(nextFile)
                    await vscode.window.showTextDocument(document)
                    
                    vscode.window.showInformationMessage(
                      `ğŸ“‚ å·²è‡ªåŠ¨æ‰“å¼€ä¸‹ä¸€ä¸ªå†²çªæ–‡ä»¶ (${remainingConflicts.length} ä¸ªå‰©ä½™)`,
                      { modal: false }
                    )
                    
                    vscode.window.setStatusBarMessage(
                      `ğŸ“ æ­£åœ¨è§£å†³å†²çª ${conflictFileMapping.size - remainingConflicts.length + 1}/${conflictFileMapping.size} - ä¿å­˜æ–‡ä»¶åè‡ªåŠ¨åº”ç”¨è§£å†³æ–¹æ¡ˆ`,
                      10000
                    )
                  } catch (error) {
                    console.error('æ‰“å¼€ä¸‹ä¸€ä¸ªå†²çªæ–‡ä»¶å¤±è´¥:', error)
                  }
                }, 1000)
              } else {
                // æ‰€æœ‰å†²çªéƒ½å·²è§£å†³
                vscode.window.showInformationMessage(
                  `ğŸ‰ æ‰€æœ‰å†²çªéƒ½å·²è§£å†³ï¼\n\næ‚¨ç°åœ¨å¯ä»¥é‡æ–°æ‰§è¡ŒåŒæ­¥æ“ä½œã€‚`,
                  { modal: false },
                  'é‡æ–°åŒæ­¥'
                ).then(choice => {
                  if (choice === 'é‡æ–°åŒæ­¥') {
                    // è§¦å‘é‡æ–°åŒæ­¥
                    vscode.commands.executeCommand('starcode-snippets.cloudSync')
                  }
                })
                
                // æ¸…ç†ä¸´æ—¶ç›®å½•
                setTimeout(async () => {
                  await this.cleanupTempConflictFiles(tempDir)
                }, 2000)
              }
              
            } catch (saveError) {
              console.error('ä¿å­˜è§£å†³åçš„ä»£ç ç‰‡æ®µå¤±è´¥:', saveError)
              vscode.window.showErrorMessage(
                `ä¿å­˜è§£å†³æ–¹æ¡ˆå¤±è´¥ï¼š${saveError instanceof Error ? saveError.message : 'æœªçŸ¥é”™è¯¯'}`
              )
                         }
           }
         }
       } else {
         // å†²çªè§£å†³å¤±è´¥ï¼Œæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
         const conflict = conflictFileMapping.get(filePath)
         if (conflict && resolvedResult.errors.length > 0) {
           // æ˜¾ç¤ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
           vscode.window.showErrorMessage(
             `âŒ å†²çªè§£å†³ä¸å®Œæ•´ï¼š${conflict.fullPath}\n\nå‘ç°ä»¥ä¸‹é—®é¢˜ï¼š\n${resolvedResult.errors.map(err => `â€¢ ${err}`).join('\n')}\n\nè¯·ä¿®æ­£è¿™äº›é—®é¢˜åä¿å­˜æ–‡ä»¶ã€‚`,
             { modal: false },
             'äº†è§£'
           )
           
           // æ›´æ–°çŠ¶æ€æ æ˜¾ç¤ºé”™è¯¯
           vscode.window.setStatusBarMessage(
             `âŒ å†²çªè§£å†³å¤±è´¥ï¼š${path.basename(conflict.fullPath)} - è¯·æ£€æŸ¥å†²çªæ ‡è®°`,
             10000
           )
         }
       }
     } catch (error) {
       console.error('å¤„ç†å†²çªæ–‡ä»¶å˜æ›´å¤±è´¥:', error)
     }
   }

  /**
   * å°†ä»£ç ç‰‡æ®µè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
   */
  private snippetToJson(snippet: CodeSnippetDeprecatedType): string {
    return JSON.stringify(snippet, null, 2)
  }

  /**
   * ä»JSONå­—ç¬¦ä¸²è§£æä»£ç ç‰‡æ®µ
   */
  private jsonToSnippet(json: string): CodeSnippetDeprecatedType {
    return JSON.parse(json)
  }

  /**
   * å°†ä»£ç ç‰‡æ®µå’Œç›®å½•æ•°æ®å†™å…¥Gitä»“åº“æ–‡ä»¶ç³»ç»Ÿ
   */
  private async writeDataToGitRepo(snippets: CodeSnippetDeprecatedType[], directories: DirectoryDeprecatedType[], updateTimestamp: boolean = true): Promise<void> {
    const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
    
    // ç¡®ä¿ä»“åº“ç›®å½•å­˜åœ¨
    if (!fs.existsSync(effectiveLocalPath)) {
      fs.mkdirSync(effectiveLocalPath, { recursive: true })
    }

    // å‡†å¤‡æ–°çš„æ–‡ä»¶å†…å®¹
    const newSnippetsContent = JSON.stringify(snippets, null, 2)
    const newDirectoriesContent = JSON.stringify(directories, null, 2)

    const snippetsFile = path.join(effectiveLocalPath, 'snippets.json')
    const directoriesFile = path.join(effectiveLocalPath, 'directories.json')
    const metadataFile = path.join(effectiveLocalPath, '.starcode-meta.json')

    // æ£€æŸ¥ä»£ç ç‰‡æ®µæ–‡ä»¶æ˜¯å¦éœ€è¦æ›´æ–°
    let needUpdateSnippets = true
    if (fs.existsSync(snippetsFile)) {
      try {
        const existingSnippetsContent = fs.readFileSync(snippetsFile, 'utf8')
        needUpdateSnippets = existingSnippetsContent !== newSnippetsContent
      } catch (error) {
        needUpdateSnippets = true
      }
    }

    // æ£€æŸ¥ç›®å½•æ–‡ä»¶æ˜¯å¦éœ€è¦æ›´æ–°
    let needUpdateDirectories = true
    if (fs.existsSync(directoriesFile)) {
      try {
        const existingDirectoriesContent = fs.readFileSync(directoriesFile, 'utf8')
        needUpdateDirectories = existingDirectoriesContent !== newDirectoriesContent
      } catch (error) {
        needUpdateDirectories = true
      }
    }

    // å‡†å¤‡å…ƒæ•°æ®
    let metadata: any = {
      version: '2.0.0',
      totalSnippets: snippets.length,
      totalDirectories: directories.length,
      syncMethod: 'git'
    }

    // å¤„ç†æ—¶é—´æˆ³
    if (updateTimestamp) {
      metadata.lastSync = new Date().toISOString()
    } else {
      // å°è¯•è¯»å–ç°æœ‰çš„æ—¶é—´æˆ³
      try {
        if (fs.existsSync(metadataFile)) {
          const existingMetadata = JSON.parse(fs.readFileSync(metadataFile, 'utf8'))
          metadata.lastSync = existingMetadata.lastSync || new Date().toISOString()
        } else {
          metadata.lastSync = new Date().toISOString()
        }
      } catch (error) {
        metadata.lastSync = new Date().toISOString()
      }
    }

    // æ£€æŸ¥å…ƒæ•°æ®æ–‡ä»¶æ˜¯å¦éœ€è¦æ›´æ–°
    const newMetadataContent = JSON.stringify(metadata, null, 2)
    let needUpdateMetadata = true
    if (fs.existsSync(metadataFile)) {
      try {
        const existingMetadataContent = fs.readFileSync(metadataFile, 'utf8')
        needUpdateMetadata = existingMetadataContent !== newMetadataContent
      } catch (error) {
        needUpdateMetadata = true
      }
    }

    // åªæœ‰åœ¨å†…å®¹çœŸæ­£å‘ç”Ÿå˜åŒ–æ—¶æ‰å†™å…¥æ–‡ä»¶
    if (needUpdateSnippets) {
      fs.writeFileSync(snippetsFile, newSnippetsContent, 'utf8')
      // console.log(`æ›´æ–°äº†ä»£ç ç‰‡æ®µæ–‡ä»¶: ${snippets.length} ä¸ªç‰‡æ®µ`)
    }

    if (needUpdateDirectories) {
      fs.writeFileSync(directoriesFile, newDirectoriesContent, 'utf8')
      // console.log(`æ›´æ–°äº†ç›®å½•æ–‡ä»¶: ${directories.length} ä¸ªç›®å½•`)
    }

    if (needUpdateMetadata) {
      fs.writeFileSync(metadataFile, newMetadataContent, 'utf8')
      // console.log(`æ›´æ–°äº†å…ƒæ•°æ®æ–‡ä»¶`)
    }

    // å¦‚æœæ²¡æœ‰ä»»ä½•æ–‡ä»¶éœ€è¦æ›´æ–°ï¼Œè®°å½•æ—¥å¿—
    if (!needUpdateSnippets && !needUpdateDirectories && !needUpdateMetadata) {
      // console.log('æ‰€æœ‰æ–‡ä»¶å†…å®¹å‡æ— å˜åŒ–ï¼Œè·³è¿‡å†™å…¥æ“ä½œ')
    }
  }

  /**
   * ä»Gitä»“åº“æ–‡ä»¶ç³»ç»Ÿè¯»å–ä»£ç ç‰‡æ®µå’Œç›®å½•æ•°æ®
   */
  public async readDataFromGitRepo(): Promise<{ snippets: CodeSnippetDeprecatedType[]; directories: DirectoryDeprecatedType[] }> {
    const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
    
    const snippetsFile = path.join(effectiveLocalPath, 'snippets.json')
    const directoriesFile = path.join(effectiveLocalPath, 'directories.json')

    let snippets: CodeSnippetDeprecatedType[] = []
    let directories: DirectoryDeprecatedType[] = []

    try {
      if (fs.existsSync(snippetsFile)) {
        const snippetsData = fs.readFileSync(snippetsFile, 'utf8')
        snippets = JSON.parse(snippetsData)
      }
    } catch (error) {
      console.warn('è¯»å–ä»£ç ç‰‡æ®µæ–‡ä»¶å¤±è´¥:', error)
    }

    try {
      if (fs.existsSync(directoriesFile)) {
        const directoriesData = fs.readFileSync(directoriesFile, 'utf8')
        directories = JSON.parse(directoriesData)
      }
    } catch (error) {
      console.warn('è¯»å–ç›®å½•æ–‡ä»¶å¤±è´¥:', error)
    }

    // console.log(`ä»Gitä»“åº“è¯»å– ${snippets.length} ä¸ªä»£ç ç‰‡æ®µå’Œ ${directories.length} ä¸ªç›®å½•`)
    return { snippets, directories }
  }

  /**
   * æ£€æµ‹æœ¬åœ°å˜æ›´ - æ¯”è¾ƒVSCodeå­˜å‚¨ä¸Gitä»“åº“æ–‡ä»¶
   */
  public async detectLocalChanges(currentSnippets: CodeSnippetDeprecatedType[], currentDirectories: DirectoryDeprecatedType[]): Promise<{
    hasChanges: boolean;
    type: 'none' | 'local_only' | 'repo_only' | 'both_differ';
    details: string;
  }> {
    try {
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      
      // æ£€æŸ¥Gitä»“åº“æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      const snippetsFile = path.join(effectiveLocalPath, 'snippets.json')
      const directoriesFile = path.join(effectiveLocalPath, 'directories.json')
      
      const snippetsFileExists = fs.existsSync(snippetsFile)
      const directoriesFileExists = fs.existsSync(directoriesFile)

      // å¦‚æœGitä»“åº“æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯´æ˜éœ€è¦é¦–æ¬¡åŒæ­¥
      if (!snippetsFileExists || !directoriesFileExists) {
        return {
          hasChanges: currentSnippets.length > 0 || currentDirectories.length > 0,
          type: 'local_only',
          details: `æœ¬åœ°æœ‰ ${currentSnippets.length} ä¸ªä»£ç ç‰‡æ®µå’Œ ${currentDirectories.length} ä¸ªç›®å½•éœ€è¦é¦–æ¬¡åŒæ­¥åˆ°Gitä»“åº“`
        }
      }

      // è¯»å–Gitä»“åº“ä¸­çš„æ•°æ®
      const repoData = await this.readDataFromGitRepo()
      
      // æ¯”è¾ƒæ•°æ®æ˜¯å¦ä¸€è‡´ - ä½¿ç”¨V2æ ¼å¼çš„fullPath
      const getSortKey = (item: any) => {
        return item.fullPath || ''
      }
      
      const snippetsEqual = JSON.stringify(currentSnippets.sort((a, b) => getSortKey(a).localeCompare(getSortKey(b)))) === 
                           JSON.stringify(repoData.snippets.sort((a, b) => getSortKey(a).localeCompare(getSortKey(b))))
      const directoriesEqual = JSON.stringify(currentDirectories.sort((a, b) => getSortKey(a).localeCompare(getSortKey(b)))) === 
                               JSON.stringify(repoData.directories.sort((a, b) => getSortKey(a).localeCompare(getSortKey(b))))

      // æ£€æŸ¥å…ƒæ•°æ®æ˜¯å¦éœ€è¦æ›´æ–°ï¼ˆå¿½ç•¥æ—¶é—´æˆ³ï¼‰
      const metadataFile = path.join(effectiveLocalPath, '.starcode-meta.json')
      let metadataEqual = true
      
      if (fs.existsSync(metadataFile)) {
        try {
          const existingMetadata = JSON.parse(fs.readFileSync(metadataFile, 'utf8'))
          // æ¯”è¾ƒé™¤æ—¶é—´æˆ³å¤–çš„å…ƒæ•°æ®
          const currentMetadata = {
            version: '2.0.0',
            totalSnippets: currentSnippets.length,
            totalDirectories: currentDirectories.length,
            syncMethod: 'git'
          }
          const existingMetadataWithoutTimestamp = {
            version: existingMetadata.version,
            totalSnippets: existingMetadata.totalSnippets,
            totalDirectories: existingMetadata.totalDirectories,
            syncMethod: existingMetadata.syncMethod
          }
          metadataEqual = JSON.stringify(currentMetadata) === JSON.stringify(existingMetadataWithoutTimestamp)
        } catch (error) {
          metadataEqual = false
        }
      } else {
        metadataEqual = false
      }

      if (snippetsEqual && directoriesEqual && metadataEqual) {
        return {
          hasChanges: false,
          type: 'none',
          details: 'æœ¬åœ°æ•°æ®ä¸Gitä»“åº“æ•°æ®ä¸€è‡´'
        }
      }

      return {
        hasChanges: true,
        type: 'both_differ',
        details: `æ•°æ®å·®å¼‚: ä»£ç ç‰‡æ®µ${snippetsEqual ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'}, ç›®å½•${directoriesEqual ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'}, å…ƒæ•°æ®${metadataEqual ? 'ä¸€è‡´' : 'ä¸ä¸€è‡´'}`
      }
    } catch (error) {
      console.error('æ£€æµ‹æœ¬åœ°å˜æ›´å¤±è´¥:', error)
      return {
        hasChanges: true,
        type: 'local_only',
        details: `æ£€æµ‹å˜æ›´æ—¶å‡ºé”™: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      }
    }
  }

  /**
   * æ£€æŸ¥è¿œç¨‹æ˜¯å¦æœ‰æ›´æ–°
   */
  public async checkRemoteUpdates(): Promise<{
    hasUpdates: boolean;
    details: string;
  }> {
    if (!this.isConfigured()) {
      throw new Error('äº‘ç«¯åŒæ­¥æœªé…ç½®')
    }

    try {
      const git = await this.getGitInstance()
      
      // æ‰§è¡Œfetchè·å–è¿œç¨‹æ›´æ–°
      await git.fetch()
      
      // æ£€æŸ¥å½“å‰åˆ†æ”¯ä¸è¿œç¨‹åˆ†æ”¯çš„å·®å¼‚
      const branch = this.config.defaultBranch || 'main'
      const status = await git.status()
      
      // æ£€æŸ¥æ˜¯å¦æœ‰è¿œç¨‹æäº¤é¢†å…ˆæœ¬åœ°
      const localRef = `HEAD`
      const remoteRef = `origin/${branch}`
      
      try {
        // æ£€æŸ¥è¿œç¨‹åˆ†æ”¯æ˜¯å¦å­˜åœ¨ä»¥åŠæ˜¯å¦æœ‰æ–°çš„æäº¤
        const log = await git.log({ from: localRef, to: remoteRef })
        const hasRemoteCommits = log.total > 0
        
        if (hasRemoteCommits) {
          return {
            hasUpdates: true,
            details: `è¿œç¨‹åˆ†æ”¯æœ‰ ${log.total} ä¸ªæ–°æäº¤éœ€è¦æ‹‰å–`
          }
        }
        
        return {
          hasUpdates: false,
          details: 'è¿œç¨‹æ²¡æœ‰æ–°çš„æ›´æ–°'
        }
      } catch (logError) {
        // å¦‚æœè¿œç¨‹åˆ†æ”¯ä¸å­˜åœ¨æˆ–å…¶ä»–é”™è¯¯ï¼Œè¯´æ˜å¯èƒ½æ˜¯é¦–æ¬¡æ¨é€
        console.warn('æ£€æŸ¥è¿œç¨‹æ›´æ–°æ—¶å‡ºç°é”™è¯¯:', logError)
        return {
          hasUpdates: false,
          details: 'è¿œç¨‹åˆ†æ”¯å¯èƒ½ä¸å­˜åœ¨ï¼Œå°†æ‰§è¡Œé¦–æ¬¡æ¨é€'
        }
      }
    } catch (error) {
      console.error('æ£€æŸ¥è¿œç¨‹æ›´æ–°å¤±è´¥:', error)
      throw new Error(`æ£€æŸ¥è¿œç¨‹æ›´æ–°å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`)
    }
  }

  /**
   * ä»äº‘ç«¯æ‹‰å–æ•°æ®ï¼ˆå®‰å…¨æ¨¡å¼ï¼‰
   * ä¸“é—¨ç”¨äºè·å–è¿œç¨‹æ•°æ®è€Œä¸æ¨é€æœ¬åœ°æ•°æ®
   */
  public async pullFromCloud(): Promise<{ success: boolean; message: string; data?: { snippets: CodeSnippetDeprecatedType[]; directories: DirectoryDeprecatedType[] } }> {
    if (!this.isConfigured()) {
      return {
        success: false,
        message: 'äº‘ç«¯åŒæ­¥æœªé…ç½®ï¼Œè¯·å…ˆé…ç½®Gitä»“åº“ä¿¡æ¯'
      }
    }

    try {
      // console.log('å¼€å§‹ä»äº‘ç«¯æ‹‰å–æ•°æ®...')
      
      // 1. è·å–Gitå®ä¾‹
      const git = await this.getGitInstance()
      
      // 2. æ£€æŸ¥è¿œç¨‹ä»“åº“çŠ¶æ€
      const remoteRefs = await git.listRemote(['--heads', 'origin'])
      const isRemoteEmpty = !remoteRefs || remoteRefs.trim() === ''
      
      if (isRemoteEmpty) {
        return {
          success: false,
          message: 'è¿œç¨‹ä»“åº“ä¸ºç©ºï¼Œæ²¡æœ‰æ•°æ®å¯ä»¥æ‹‰å–ã€‚\n\nè¿™å¯èƒ½æ˜¯ä¸€ä¸ªæ–°åˆ›å»ºçš„ä»“åº“ï¼Œè¯·å…ˆåœ¨å…¶ä»–è®¾å¤‡ä¸Šæ¨é€æ•°æ®ã€‚'
        }
      }
      
      // 3. ç¡®ä¿åœ¨æ­£ç¡®çš„åˆ†æ”¯ä¸Š
      const targetBranch = this.config.defaultBranch || 'main'
      try {
        const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD'])
        if (currentBranch !== targetBranch) {
          // æ£€æŸ¥ç›®æ ‡åˆ†æ”¯æ˜¯å¦å­˜åœ¨
          const localBranches = await git.branchLocal()
          if (!localBranches.all.includes(targetBranch)) {
            // å¦‚æœç›®æ ‡åˆ†æ”¯ä¸å­˜åœ¨ï¼Œä»è¿œç¨‹åˆ›å»º
            await git.checkoutLocalBranch(targetBranch)
          } else {
            await git.checkout(targetBranch)
          }
        }
      } catch (branchError) {
        console.warn('åˆ†æ”¯æ£€æŸ¥å¤±è´¥:', branchError)
      }
      
      // 4. å¤‡ä»½å½“å‰çš„æœ¬åœ°æ•°æ®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      const backupDir = path.join(effectiveLocalPath, '.backup-pull-' + Date.now())
      
      let hasLocalBackup = false
      try {
        const snippetsFile = path.join(effectiveLocalPath, 'snippets.json')
        const directoriesFile = path.join(effectiveLocalPath, 'directories.json')
        
        if (fs.existsSync(snippetsFile) || fs.existsSync(directoriesFile)) {
          fs.mkdirSync(backupDir, { recursive: true })
          
          if (fs.existsSync(snippetsFile)) {
            fs.copyFileSync(snippetsFile, path.join(backupDir, 'snippets.json'))
          }
          if (fs.existsSync(directoriesFile)) {
            fs.copyFileSync(directoriesFile, path.join(backupDir, 'directories.json'))
          }
          
          hasLocalBackup = true
          // console.log(`å·²å¤‡ä»½æœ¬åœ°æ•°æ®åˆ°: ${backupDir}`)
        }
      } catch (backupError) {
        console.warn('å¤‡ä»½æœ¬åœ°æ•°æ®å¤±è´¥:', backupError)
      }
      
      // 5. æ‹‰å–è¿œç¨‹æ•°æ®
      try {
        await this.gitPull(targetBranch)
        // console.log('è¿œç¨‹æ•°æ®æ‹‰å–æˆåŠŸ')
      } catch (pullError) {
        const errorMessage = pullError instanceof Error ? pullError.message : 'æœªçŸ¥é”™è¯¯'
        
        // æ¢å¤å¤‡ä»½ï¼ˆå¦‚æœæœ‰ï¼‰
        if (hasLocalBackup) {
          try {
            const snippetsBackup = path.join(backupDir, 'snippets.json')
            const directoriesBackup = path.join(backupDir, 'directories.json')
            
            if (fs.existsSync(snippetsBackup)) {
              fs.copyFileSync(snippetsBackup, path.join(effectiveLocalPath, 'snippets.json'))
            }
            if (fs.existsSync(directoriesBackup)) {
              fs.copyFileSync(directoriesBackup, path.join(effectiveLocalPath, 'directories.json'))
            }
            
            await this.deleteDirectory(backupDir)
          } catch (restoreError) {
            console.warn('æ¢å¤å¤‡ä»½å¤±è´¥:', restoreError)
          }
        }
        
        return {
          success: false,
          message: `ä»äº‘ç«¯æ‹‰å–æ•°æ®å¤±è´¥: ${errorMessage}\n\nè¯·æ£€æŸ¥ï¼š\nâ€¢ ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\nâ€¢ è®¤è¯ä¿¡æ¯æ˜¯å¦æ­£ç¡®\nâ€¢ è¿œç¨‹ä»“åº“æ˜¯å¦å­˜åœ¨æŒ‡å®šåˆ†æ”¯ '${targetBranch}'`
        }
      }
      
      // 6. è¯»å–æ‹‰å–çš„æ•°æ®
      const pulledData = await this.readDataFromGitRepo()
      
      // 7. æ¸…ç†å¤‡ä»½ï¼ˆæ‹‰å–æˆåŠŸï¼‰
      if (hasLocalBackup && fs.existsSync(backupDir)) {
        try {
          await this.deleteDirectory(backupDir)
        } catch (cleanupError) {
          console.warn('æ¸…ç†å¤‡ä»½å¤±è´¥:', cleanupError)
        }
      }
      
      return {
        success: true,
        message: `æˆåŠŸä»äº‘ç«¯æ‹‰å–æ•°æ®ï¼\n\nè·å–åˆ°ï¼š\nâ€¢ ${pulledData.snippets.length} ä¸ªä»£ç ç‰‡æ®µ\nâ€¢ ${pulledData.directories.length} ä¸ªç›®å½•\n\næ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°Gitä»“åº“ï¼Œæ‚¨å¯ä»¥é€‰æ‹©æ˜¯å¦å¯¼å…¥åˆ°VSCodeã€‚`,
        data: pulledData
      }
      
    } catch (error) {
      console.error('ä»äº‘ç«¯æ‹‰å–æ•°æ®å¤±è´¥:', error)
      return {
        success: false,
        message: `ä»äº‘ç«¯æ‹‰å–æ•°æ®å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      }
    }
  }

  /**
   * æ‰§è¡Œå®Œæ•´åŒæ­¥ï¼ˆé‡æ–°å®ç°çš„Gitç‰ˆæœ¬ï¼‰
   */
  public async performSync(currentSnippets: CodeSnippetDeprecatedType[], currentDirectories: DirectoryDeprecatedType[]): Promise<SyncResult> {
    if (!this.isConfigured()) {
      return {
        success: false,
        message: 'äº‘ç«¯åŒæ­¥æœªé…ç½®ï¼Œè¯·å…ˆé…ç½®Gitä»“åº“ä¿¡æ¯',
      }
    }

    // æ›´æ–°åŒæ­¥çŠ¶æ€
    const status = SettingsManager.getCloudSyncStatus()
    status.isSyncing = true
    await SettingsManager.saveCloudSyncStatus(status)

    try {
      // console.log('å¼€å§‹Gitäº‘ç«¯åŒæ­¥...')
      
      // 0. æ¸…ç†æ—§çš„ä¸´æ—¶å†²çªæ–‡ä»¶å’Œå‡­æ®æ–‡ä»¶
      try {
        // æ¸…ç†æ—§çš„å†²çªæ–‡ä»¶
        await this.cleanupOldConflictFiles()
        
        // æ¸…ç†ä¸´æ—¶å‡­æ®æ–‡ä»¶
        const tempFilesCheck = await TempFilesCleaner.checkNeedCleanup()
        if (tempFilesCheck.needCleanup) {
          // console.log(`å‘ç° ${tempFilesCheck.fileCount} ä¸ªä¸´æ—¶å‡­æ®æ–‡ä»¶ï¼Œè‡ªåŠ¨æ¸…ç†ä¸­...`)
          const cleanupResult = await TempFilesCleaner.cleanupGiteeCredFiles()
          if (cleanupResult.success && cleanupResult.deletedFiles.length > 0) {
            // console.log(`å·²è‡ªåŠ¨æ¸…ç† ${cleanupResult.deletedFiles.length} ä¸ªä¸´æ—¶å‡­æ®æ–‡ä»¶`)
          }
        }
      } catch (cleanupError) {
        console.warn('æ¸…ç†ä¸´æ—¶æ–‡ä»¶æ—¶å‡ºé”™ï¼ˆä¸å½±å“åŒæ­¥ï¼‰:', cleanupError)
      }
      
      // 1. è·å–Gité…ç½®å¹¶ç¡®ä¿ä»“åº“åˆå§‹åŒ–
      const git = await this.getGitInstance()
      // console.log('Gitä»“åº“å·²åˆå§‹åŒ–å¹¶é…ç½®è¿œç¨‹')

      // Giteeç‰¹æ®Šå¤„ç†
      if (this.config.provider === 'gitee') {
        // console.log('æ£€æµ‹åˆ°Giteeå¹³å°ï¼Œä½¿ç”¨ç‰¹æ®Šå¤„ç†æµç¨‹...')
      }

      // 2. æ£€æŸ¥å¹¶ç¡®ä¿æ­£ç¡®çš„åˆ†æ”¯å­˜åœ¨
      const targetBranch = this.config.defaultBranch || 'main'
      // console.log(`ç›®æ ‡åˆ†æ”¯: ${targetBranch}`)
      
      try {
        // æ£€æŸ¥å½“å‰åˆ†æ”¯çŠ¶æ€
        const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD'])
        // console.log(`å½“å‰åˆ†æ”¯: ${currentBranch}`)
        
        // è·å–æ‰€æœ‰æœ¬åœ°åˆ†æ”¯
        const localBranches = await git.branchLocal()
        const targetBranchExists = localBranches.all.includes(targetBranch)
        
        // console.log(`æœ¬åœ°åˆ†æ”¯åˆ—è¡¨: ${localBranches.all.join(', ')}`)
        // console.log(`ç›®æ ‡åˆ†æ”¯ ${targetBranch} æ˜¯å¦å­˜åœ¨: ${targetBranchExists}`)
        
        if (!targetBranchExists) {
          // console.log(`ç›®æ ‡åˆ†æ”¯ ${targetBranch} ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`)
          
          // å¦‚æœç›®æ ‡åˆ†æ”¯ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¹¶åˆ‡æ¢åˆ°è¯¥åˆ†æ”¯
          if (localBranches.all.length > 0) {
            // å¦‚æœæœ‰å…¶ä»–åˆ†æ”¯ï¼ŒåŸºäºå½“å‰åˆ†æ”¯åˆ›å»ºæ–°åˆ†æ”¯
            await git.checkoutLocalBranch(targetBranch)
          } else {
            // å¦‚æœæ²¡æœ‰ä»»ä½•åˆ†æ”¯ï¼Œéœ€è¦å…ˆæäº¤ä¸€äº›å†…å®¹æ‰èƒ½åˆ›å»ºåˆ†æ”¯
            // console.log('ä»“åº“æ²¡æœ‰ä»»ä½•åˆ†æ”¯ï¼Œå°†åˆ›å»ºåˆå§‹æäº¤...')
          }
        } else if (currentBranch !== targetBranch) {
          // console.log(`åˆ‡æ¢åˆ°ç›®æ ‡åˆ†æ”¯ ${targetBranch}`)
          await git.checkout(targetBranch)
        }
      } catch (branchError) {
        console.warn('åˆ†æ”¯æ£€æŸ¥/åˆ‡æ¢å¤±è´¥:', branchError)
        // å¦‚æœåˆ†æ”¯æ“ä½œå¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œä½†è®°å½•è­¦å‘Š
      }

      // 3. æ£€æŸ¥è¿œç¨‹ä»“åº“æ˜¯å¦ä¸ºç©ºï¼ˆæ•°æ®å®‰å…¨æ£€æŸ¥ï¼‰
      let isRemoteEmpty = false
      let remotePullSuccess = false
      let remoteHasData = false

      try {
        // é¦–å…ˆæ£€æŸ¥è¿œç¨‹æ˜¯å¦æœ‰åˆ†æ”¯
        const remoteRefs = await git.listRemote(['--heads', 'origin'])
        isRemoteEmpty = !remoteRefs || remoteRefs.trim() === ''
        
        if (!isRemoteEmpty) {
          // è¿œç¨‹ä¸ä¸ºç©ºï¼Œå°è¯•æ‹‰å–å¹¶æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
      try {
        await this.gitPull()
        remotePullSuccess = true
            
            // æ‹‰å–æˆåŠŸåï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å®é™…çš„ä»£ç ç‰‡æ®µæ•°æ®
            const remoteData = await this.readDataFromGitRepo()
            remoteHasData = remoteData.snippets.length > 0 || remoteData.directories.length > 0
            
            // console.log(`è¿œç¨‹æ•°æ®æ£€æŸ¥: snippets=${remoteData.snippets.length}, directories=${remoteData.directories.length}`)
      } catch (pullError) {
        const errorMessage = pullError instanceof Error ? pullError.message : 'æœªçŸ¥é”™è¯¯'
        
        // Giteeç‰¹æ®Šé”™è¯¯å¤„ç†
        if (this.config.provider === 'gitee') {
          if (errorMessage.includes('could not read Username') || 
              errorMessage.includes('Authentication failed')) {
            return {
              success: false,
              message: `Giteeè®¤è¯å¤±è´¥ï¼\n\nå¯èƒ½åŸå› ï¼š\nâ€¢ Tokenæ ¼å¼ä¸æ­£ç¡®æˆ–å·²è¿‡æœŸ\nâ€¢ Gitee APIé™åˆ¶\n\nå»ºè®®ï¼š\n1. é‡æ–°ç”Ÿæˆå¹¶æ›´æ–°Token\n2. å¦‚ä½¿ç”¨åŸºäºHTTPSçš„URLï¼Œå°è¯•åˆ‡æ¢åˆ°SSHè®¤è¯\n3. æ£€æŸ¥Giteeä»“åº“æƒé™è®¾ç½®`,
            }
          }
        }
        
        if (errorMessage.includes('couldn\'t find remote ref') || 
            errorMessage.includes('does not exist') ||
            errorMessage.includes('no upstream branch')) {
          // console.log('è¿œç¨‹åˆ†æ”¯ä¸å­˜åœ¨ï¼Œå°†æ‰§è¡Œé¦–æ¬¡æ¨é€')
          remotePullSuccess = false
        } else {
           // æ£€æŸ¥æ˜¯å¦æ˜¯åˆå¹¶å†²çª
           try {
             const gitStatus = await this.gitStatus()
             if (gitStatus.conflicted && gitStatus.conflicted.length > 0) {
               return await this.handleGitConflicts(gitStatus.conflicted)
             }
           } catch (statusError) {
             console.warn('æ£€æŸ¥GitçŠ¶æ€å¤±è´¥:', statusError)
           }
           throw pullError
        }
      }
        }
      } catch (remoteCheckError) {
        console.warn('æ£€æŸ¥è¿œç¨‹ä»“åº“çŠ¶æ€å¤±è´¥:', remoteCheckError)
        // å¦‚æœæ— æ³•æ£€æŸ¥è¿œç¨‹çŠ¶æ€ï¼Œå‡è®¾ä¸ºé¦–æ¬¡æ¨é€
        isRemoteEmpty = true
      }

      // 4. æ™ºèƒ½é¦–æ¬¡åŒæ­¥ï¼šå½“æœ¬åœ°æ— æ•°æ®ä½†è¿œç¨‹æœ‰æ•°æ®æ—¶ï¼Œè‡ªåŠ¨æ‹‰å–å¹¶åˆå¹¶
      const hasLocalData = currentSnippets.length > 0 || currentDirectories.length > 0
      let mergedSnippets = currentSnippets
      let mergedDirectories = currentDirectories
      let autoMerged = false
      
      // ä¿å­˜åˆå¹¶ç»“æœç”¨äºåç»­æ˜¾ç¤º
      let finalSnippetMergeResult: any = null
      let finalDirectoryMergeResult: any = null
      
      if (!hasLocalData && remoteHasData) {
        // æœ¬åœ°æ²¡æœ‰æ•°æ®ä½†è¿œç¨‹æœ‰æ•°æ®ï¼Œè‡ªåŠ¨æ‹‰å–è¿œç¨‹æ•°æ®è¿›è¡Œåˆå¹¶
        try {
          // console.log('æ£€æµ‹åˆ°é¦–æ¬¡åŒæ­¥åœºæ™¯ï¼Œè‡ªåŠ¨æ‹‰å–è¿œç¨‹æ•°æ®è¿›è¡Œåˆå¹¶...')
          const remoteData = await this.readDataFromGitRepo()
          
          mergedSnippets = [...currentSnippets, ...remoteData.snippets]
          mergedDirectories = [...currentDirectories, ...remoteData.directories]
          autoMerged = true
          
          // console.log(`è‡ªåŠ¨åˆå¹¶å®Œæˆ: ${remoteData.snippets.length} ä¸ªè¿œç¨‹ä»£ç ç‰‡æ®µ, ${remoteData.directories.length} ä¸ªè¿œç¨‹ç›®å½•`)
        } catch (readError) {
          // å¦‚æœè¯»å–è¿œç¨‹æ•°æ®å¤±è´¥ï¼Œä½†å·²ç»æˆåŠŸæ‹‰å–äº†ï¼Œè¯´æ˜æ•°æ®å¯èƒ½æ˜¯ç©ºçš„æˆ–æ ¼å¼æœ‰é—®é¢˜
          console.warn('è¯»å–è¿œç¨‹æ•°æ®å¤±è´¥ï¼Œä½†æ‹‰å–æˆåŠŸï¼Œå¯èƒ½è¿œç¨‹æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼å¼‚å¸¸:', readError)
          // ç»§ç»­æ‰§è¡Œï¼Œä½¿ç”¨åŸå§‹çš„æœ¬åœ°æ•°æ®
        }
      } else if (!hasLocalData && !isRemoteEmpty && !remotePullSuccess) {
        // æœ¬åœ°æ²¡æœ‰æ•°æ®ï¼Œè¿œç¨‹ä¸ä¸ºç©ºä½†æ‹‰å–å¤±è´¥ - è¿™æ˜¯çœŸæ­£éœ€è¦è­¦å‘Šçš„æƒ…å†µ
        return {
          success: false,
          message: `âš ï¸ é¦–æ¬¡åŒæ­¥å¤±è´¥ï¼\n\næ£€æµ‹åˆ°ä»¥ä¸‹æƒ…å†µï¼š\nâ€¢ æœ¬åœ°æ²¡æœ‰ä»£ç ç‰‡æ®µæ•°æ®\nâ€¢ è¿œç¨‹ä»“åº“ä¸ä¸ºç©º\nâ€¢ æ— æ³•ä»è¿œç¨‹æ‹‰å–æ•°æ®\n\nå¯èƒ½åŸå› ï¼š\nâ€¢ ç½‘ç»œè¿æ¥é—®é¢˜\nâ€¢ è®¤è¯æƒé™ä¸è¶³\nâ€¢ åˆ†æ”¯é…ç½®é”™è¯¯\n\nè¯·æ£€æŸ¥ç½‘ç»œå’Œé…ç½®åé‡è¯•ï¼Œæˆ–ä½¿ç”¨"ä»äº‘ç«¯æ‹‰å–æ•°æ®"åŠŸèƒ½æ‰‹åŠ¨æ‹‰å–ã€‚`,
        }
      } else if (hasLocalData && remoteHasData && remotePullSuccess) {
        // æœ¬åœ°å’Œè¿œç¨‹éƒ½æœ‰æ•°æ®ï¼Œè¿›è¡Œæ™ºèƒ½åˆå¹¶
        try {
          // console.log('æ£€æµ‹åˆ°æœ¬åœ°å’Œè¿œç¨‹éƒ½æœ‰æ•°æ®ï¼Œè¿›è¡Œæ™ºèƒ½åˆå¹¶...')
          const remoteData = await this.readDataFromGitRepo()
          
          // æ™ºèƒ½åˆå¹¶ç®—æ³• - å¤„ç†ä»£ç ç‰‡æ®µå†²çªå’Œå†…å®¹å·®å¼‚
          const mergeSnippets = (local: CodeSnippetDeprecatedType[], remote: CodeSnippetDeprecatedType[]): {
            merged: CodeSnippetDeprecatedType[]
            conflicts: Array<{
              id: string
              fullPath: string
              local: CodeSnippetDeprecatedType
              remote: CodeSnippetDeprecatedType
              resolution: 'use_local' | 'use_remote' | 'use_newer' | 'auto_merge' | 'manual_merge_required'
              needsManualMerge?: boolean
              conflictData?: {
                localContent: string
                remoteContent: string
                mergedContent?: string
              }
            }>
            additions: number
            manualMergeRequired: boolean
          } => {
            const merged = [...local]
            const conflicts: Array<any> = []
            let additions = 0
            let manualMergeRequired = false
            
            // åˆ›å»ºæœ¬åœ°æ•°æ®çš„æ˜ å°„ï¼Œä½¿ç”¨ fullPath ä½œä¸ºä¸»é”®
            const localMap = new Map<string, CodeSnippetDeprecatedType>()
            for (const snippet of local) {
              const key = (snippet as any).fullPath
              if (key) {
                localMap.set(key, snippet)
              }
            }
            
            for (const remoteSnippet of remote) {
              const remoteKey = (remoteSnippet as any).fullPath
              const localSnippet = remoteKey ? localMap.get(remoteKey) : undefined
              
              if (!localSnippet) {
                // è¿œç¨‹æœ‰è€Œæœ¬åœ°æ²¡æœ‰çš„ä»£ç ç‰‡æ®µï¼Œç›´æ¥æ·»åŠ 
                merged.push(remoteSnippet)
                additions++
              } else {
                // æ£€æŸ¥å†…å®¹æ˜¯å¦æœ‰å·®å¼‚
                const hasContentDiff = this.hasSnippetContentDifference(localSnippet, remoteSnippet)
                
                if (hasContentDiff) {
                  // æœ‰å†…å®¹å·®å¼‚ï¼Œéœ€è¦æ™ºèƒ½è§£å†³å†²çª
                  const resolution = this.resolveSnippetConflict(localSnippet, remoteSnippet)
                  
                  const conflictRecord = {
                    id: remoteSnippet.id,
                    fullPath: remoteKey,
                    local: localSnippet,
                    remote: remoteSnippet,
                    resolution: resolution.strategy,
                    needsManualMerge: resolution.needsManualMerge,
                    conflictData: resolution.conflictData
                  }
                  
                  conflicts.push(conflictRecord)
                  
                  // å¦‚æœéœ€è¦æ‰‹åŠ¨åˆå¹¶ï¼Œæ ‡è®°æ•´ä¸ªåˆå¹¶è¿‡ç¨‹
                  if (resolution.needsManualMerge) {
                    manualMergeRequired = true
                  }
                  
                  // æ ¹æ®è§£å†³ç­–ç•¥æ›´æ–°åˆå¹¶ç»“æœ
                  const localIndex = merged.findIndex(s => (s as any).fullPath === remoteKey)
                  if (localIndex >= 0) {
                    merged[localIndex] = resolution.resolved
                  }
                }
                // å¦‚æœæ²¡æœ‰å†…å®¹å·®å¼‚ï¼Œä¿æŒæœ¬åœ°ç‰ˆæœ¬ä¸å˜
              }
            }
            
            return { merged, conflicts, additions, manualMergeRequired }
          }
          
          const mergeDirectories = (local: DirectoryDeprecatedType[], remote: DirectoryDeprecatedType[]): {
            merged: DirectoryDeprecatedType[]
            conflicts: Array<{
              id: string
              fullPath: string
              local: DirectoryDeprecatedType
              remote: DirectoryDeprecatedType
              resolution: 'use_local' | 'use_remote' | 'use_newer'
              needsManualMerge?: boolean
            }>
            additions: number
            manualMergeRequired: boolean
          } => {
            const merged = [...local]
            const conflicts: Array<any> = []
            let additions = 0
            let manualMergeRequired = false
            
            // åˆ›å»ºæœ¬åœ°æ•°æ®çš„æ˜ å°„
            const localMap = new Map<string, DirectoryDeprecatedType>()
            for (const directory of local) {
              const key = (directory as any).fullPath
              if (key) {
                localMap.set(key, directory)
              }
            }
            
            for (const remoteDir of remote) {
              const remoteKey = (remoteDir as any).fullPath
              const localDir = remoteKey ? localMap.get(remoteKey) : undefined
              
              if (!localDir) {
                // è¿œç¨‹æœ‰è€Œæœ¬åœ°æ²¡æœ‰çš„ç›®å½•ï¼Œç›´æ¥æ·»åŠ 
                merged.push(remoteDir)
                additions++
              } else {
                // æ£€æŸ¥ç›®å½•å±æ€§æ˜¯å¦æœ‰å·®å¼‚
                const hasContentDiff = this.hasDirectoryContentDifference(localDir, remoteDir)
                
                if (hasContentDiff) {
                  // æœ‰å·®å¼‚ï¼Œéœ€è¦è§£å†³å†²çª
                  const resolution = this.resolveDirectoryConflict(localDir, remoteDir)
                  
                  const conflictRecord = {
                    id: remoteDir.id,
                    fullPath: remoteKey,
                    local: localDir,
                    remote: remoteDir,
                    resolution: resolution.strategy,
                    needsManualMerge: false // ç›®å½•å†²çªé€šå¸¸ä¸éœ€è¦æ‰‹åŠ¨åˆå¹¶
                  }
                  
                  conflicts.push(conflictRecord)
                  
                  // æ ¹æ®è§£å†³ç­–ç•¥æ›´æ–°åˆå¹¶ç»“æœ
                  const localIndex = merged.findIndex(d => (d as any).fullPath === remoteKey)
                  if (localIndex >= 0) {
                    merged[localIndex] = resolution.resolved
                  }
                }
              }
            }
            
            return { merged, conflicts, additions, manualMergeRequired }
          }
          
          const originalSnippetCount = mergedSnippets.length
          const originalDirCount = mergedDirectories.length
          
          const snippetMergeResult = mergeSnippets(currentSnippets, remoteData.snippets)
          const directoryMergeResult = mergeDirectories(currentDirectories, remoteData.directories)
          
          // ä¿å­˜åˆå¹¶ç»“æœç”¨äºåç»­æ˜¾ç¤º
          finalSnippetMergeResult = snippetMergeResult
          finalDirectoryMergeResult = directoryMergeResult
          
          mergedSnippets = snippetMergeResult.merged
          mergedDirectories = directoryMergeResult.merged
          
          const newSnippetCount = snippetMergeResult.additions
          const newDirCount = directoryMergeResult.additions
          const totalConflicts = snippetMergeResult.conflicts.length + directoryMergeResult.conflicts.length
          
          if (newSnippetCount > 0 || newDirCount > 0 || totalConflicts > 0) {
            autoMerged = true
            // console.log(`æ™ºèƒ½åˆå¹¶å®Œæˆ: æ–°å¢ ${newSnippetCount} ä¸ªè¿œç¨‹ä»£ç ç‰‡æ®µ, ${newDirCount} ä¸ªè¿œç¨‹ç›®å½•, è§£å†³ ${totalConflicts} ä¸ªå†²çª`)
            
            // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦æ‰‹åŠ¨åˆå¹¶çš„å†²çª
            const needsManualMerge = snippetMergeResult.manualMergeRequired || directoryMergeResult.manualMergeRequired
            
            if (needsManualMerge) {
              // å¤„ç†éœ€è¦æ‰‹åŠ¨åˆå¹¶çš„å†²çª
              const manualMergeResult = await this.handleManualMergeConflicts(
                snippetMergeResult.conflicts.filter(c => c.needsManualMerge),
                directoryMergeResult.conflicts.filter(c => c.needsManualMerge)
              )
              
              if (!manualMergeResult.success) {
                // ç”¨æˆ·å–æ¶ˆäº†æ‰‹åŠ¨åˆå¹¶ï¼Œè¿”å›é”™è¯¯
                return {
                  success: false,
                  message: `åŒæ­¥ä¸­æ–­ï¼šæ£€æµ‹åˆ° ${manualMergeResult.conflictCount} ä¸ªéœ€è¦æ‰‹åŠ¨è§£å†³çš„å†²çªã€‚\n\n${manualMergeResult.message}\n\nè¯·è§£å†³å†²çªåé‡æ–°æ‰§è¡ŒåŒæ­¥ã€‚`,
                  conflictsDetected: true,
                  conflictDetails: manualMergeResult.conflictFiles
                }
              }
              
              // æ‰‹åŠ¨åˆå¹¶æˆåŠŸï¼Œæ›´æ–°åˆå¹¶ç»“æœ
              if (manualMergeResult.resolvedSnippets) {
                // æ›´æ–°è§£å†³äº†çš„ä»£ç ç‰‡æ®µ
                for (const resolvedSnippet of manualMergeResult.resolvedSnippets) {
                  const index = mergedSnippets.findIndex(s => ((s as any).fullPath || s.id) === ((resolvedSnippet as any).fullPath || resolvedSnippet.id))
                  if (index >= 0) {
                    mergedSnippets[index] = resolvedSnippet
                  }
                }
              }
            }
            
            // è®°å½•å†²çªè§£å†³è¯¦æƒ…ï¼ˆç”¨äºè°ƒè¯•å’Œç”¨æˆ·åé¦ˆï¼‰
            if (totalConflicts > 0) {
              console.log('å†²çªè§£å†³è¯¦æƒ…:')
              snippetMergeResult.conflicts.forEach(conflict => {
                console.log(`- ä»£ç ç‰‡æ®µ "${conflict.fullPath}": ${conflict.resolution} (æœ¬åœ°æ—¶é—´: ${conflict.local.createTime}, è¿œç¨‹æ—¶é—´: ${conflict.remote.createTime})`)
              })
              directoryMergeResult.conflicts.forEach(conflict => {
                console.log(`- ç›®å½• "${conflict.fullPath}": ${conflict.resolution}`)
              })
            }
          }
        } catch (readError) {
          console.warn('è¯»å–è¿œç¨‹æ•°æ®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®:', readError)
        }
      }

      // å¦‚æœè¿›è¡Œäº†è‡ªåŠ¨åˆå¹¶ï¼Œéœ€è¦å°†åˆå¹¶åçš„æ•°æ®åŒæ­¥åˆ°VSCodeå­˜å‚¨
      if (autoMerged && this.storageManager) {
        try {
          // console.log('å¼€å§‹å°†åˆå¹¶åçš„æ•°æ®åŒæ­¥åˆ°VSCodeå­˜å‚¨...')
          
          // æ£€æŸ¥é¡¹ç›®æ˜¯å¦éœ€è¦åŒæ­¥åˆ°VSCodeå­˜å‚¨
          let needsUpdate = false
          
          // æ£€æŸ¥æ˜¯å¦æœ‰æ–°å¢çš„ç›®å½•
          for (const directory of mergedDirectories) {
            const existingDir = currentDirectories.find(d => (d as any).fullPath === (directory as any).fullPath)
            if (!existingDir) {
              needsUpdate = true
              break
            } else {
              // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ç°æœ‰ç›®å½•
              const hasDirectoryDiff = this.hasDirectoryContentDifference(existingDir, directory)
              if (hasDirectoryDiff) {
                needsUpdate = true
                break
              }
            }
          }
          
          // æ£€æŸ¥æ˜¯å¦æœ‰æ–°å¢æˆ–æ›´æ–°çš„ä»£ç ç‰‡æ®µ
          if (!needsUpdate) {
            for (const snippet of mergedSnippets) {
              const existingSnippet = currentSnippets.find(s => (s as any).fullPath === (snippet as any).fullPath)
              if (!existingSnippet) {
                needsUpdate = true
                break
              } else {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ç°æœ‰ä»£ç ç‰‡æ®µ
                const hasSnippetDiff = this.hasSnippetContentDifference(existingSnippet, snippet)
                if (hasSnippetDiff) {
                  needsUpdate = true
                  break
                }
              }
            }
          }
          
          // å¦‚æœéœ€è¦æ›´æ–°ï¼Œè°ƒç”¨å¼ºåˆ¶å¯¼å…¥æ–¹æ³•
          if (needsUpdate) {
            // console.log('æ£€æµ‹åˆ°éœ€è¦åŒæ­¥çš„æ•°æ®å˜æ›´ï¼Œè°ƒç”¨å¼ºåˆ¶å¯¼å…¥æ–¹æ³•...')
            const importResult = await this.forceImportFromGitRepo()
            if (!importResult.success) {
              console.error('å¼ºåˆ¶å¯¼å…¥å¤±è´¥:', importResult.message)
            }
          }
          
          // æ¸…é™¤ç¼“å­˜ä»¥ç¡®ä¿ç•Œé¢æ›´æ–°
          if (this.storageManager.clearCache) {
            this.storageManager.clearCache()
          }
          
          // console.log('åˆå¹¶åçš„æ•°æ®å·²åŒæ­¥åˆ°VSCodeå­˜å‚¨')
        } catch (importError) {
          console.error('åŒæ­¥åˆå¹¶æ•°æ®åˆ°VSCodeå­˜å‚¨å¤±è´¥:', importError)
          // ä¸ä¸­æ–­åŒæ­¥æµç¨‹ï¼Œä½†è®°å½•é”™è¯¯
        }
      }

      // 5. æ£€æµ‹æœ¬åœ°å˜æ›´ï¼ˆä½¿ç”¨åˆå¹¶åçš„æ•°æ®ï¼‰
      const localChanges = await this.detectLocalChanges(mergedSnippets, mergedDirectories)
      // console.log('æœ¬åœ°å˜æ›´æ£€æµ‹ç»“æœ:', localChanges)

      // 6. å†³å®šæ˜¯å¦éœ€è¦å†™å…¥æ•°æ®
      const needsDataWrite = isRemoteEmpty || // è¿œç¨‹ä¸ºç©ºï¼Œé¦–æ¬¡æ¨é€
                            autoMerged || // è¿›è¡Œäº†è‡ªåŠ¨åˆå¹¶ï¼Œéœ€è¦å†™å…¥åˆå¹¶åçš„æ•°æ®
                            (remotePullSuccess && localChanges.hasChanges && 
                             (localChanges.type === 'local_only' || localChanges.type === 'both_differ')) || // æ‹‰å–æˆåŠŸä¸”æœ‰æœ¬åœ°å˜æ›´
                            (!remotePullSuccess && hasLocalData && isRemoteEmpty) // æ‹‰å–å¤±è´¥ä½†ç¡®è®¤è¿œç¨‹ä¸ºç©ºä¸”æœ¬åœ°æœ‰æ•°æ®
      
      if (needsDataWrite) {
        // console.log('å†™å…¥æ•°æ®åˆ°Gitä»“åº“æ–‡ä»¶ç³»ç»Ÿ...')
        // å¦‚æœè¿›è¡Œäº†è‡ªåŠ¨åˆå¹¶ï¼Œæ€»æ˜¯æ›´æ–°æ—¶é—´æˆ³ï¼›å¦åˆ™åªæœ‰åœ¨çœŸæ­£æœ‰å˜æ›´æ—¶æ‰æ›´æ–°æ—¶é—´æˆ³
        const shouldUpdateTimestamp = autoMerged || (localChanges.hasChanges && localChanges.type !== 'none')
        await this.writeDataToGitRepo(mergedSnippets, mergedDirectories, shouldUpdateTimestamp)
      }

      // 7. æ£€æŸ¥GitçŠ¶æ€å¹¶ç¡®ä¿æœ‰å†…å®¹å¯ä»¥æäº¤
      const gitStatus = await this.gitStatus()
      // console.log(`GitçŠ¶æ€ - æ–‡ä»¶å˜æ›´: ${gitStatus.files.length}, æ˜¯å¦ä¸ºä»“åº“: ${gitStatus.isClean()}`)
      
      // å¦‚æœæ²¡æœ‰ä»»ä½•æ–‡ä»¶ä¸”æœ‰æ•°æ®è¦åŒæ­¥ï¼Œå¼ºåˆ¶å†™å…¥æ•°æ®ï¼ˆä½¿ç”¨åˆå¹¶åçš„æ•°æ®ï¼‰
      const hasMergedData = mergedSnippets.length > 0 || mergedDirectories.length > 0
      if (gitStatus.files.length === 0 && hasMergedData && (isRemoteEmpty || !remoteHasData || autoMerged)) {
        // console.log('æ£€æµ‹åˆ°ç©ºä»“åº“ä½†æœ‰æ•°æ®è¦åŒæ­¥ï¼Œå¼ºåˆ¶å†™å…¥æ•°æ®...')
        // é‡æ–°æ£€æŸ¥æœ¬åœ°å˜æ›´ï¼Œä»¥ç¡®å®šæ˜¯å¦çœŸçš„éœ€è¦æ›´æ–°æ—¶é—´æˆ³
        const emptyRepoChanges = await this.detectLocalChanges(mergedSnippets, mergedDirectories)
        const shouldUpdateTimestamp = autoMerged || (emptyRepoChanges.hasChanges && emptyRepoChanges.type !== 'none')
        await this.writeDataToGitRepo(mergedSnippets, mergedDirectories, shouldUpdateTimestamp)
        
        // é‡æ–°æ£€æŸ¥çŠ¶æ€
        const newGitStatus = await this.gitStatus()
        // console.log(`å†™å…¥æ•°æ®åçš„GitçŠ¶æ€ - æ–‡ä»¶å˜æ›´: ${newGitStatus.files.length}`)
      }

      // 8. æäº¤å˜æ›´ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
      const finalGitStatus = await this.gitStatus()
      const hasUncommittedChanges = finalGitStatus.files.length > 0

      if (hasUncommittedChanges) {
        // console.log('æ£€æµ‹åˆ°æœªæäº¤çš„å˜æ›´ï¼Œå¼€å§‹æäº¤æµç¨‹...')
        
        // æ·»åŠ æ‰€æœ‰å˜æ›´åˆ°æš‚å­˜åŒº
        await this.gitAddAll()
        // console.log('å·²æ·»åŠ æ‰€æœ‰å˜æ›´åˆ°æš‚å­˜åŒº')
        
        // ç”Ÿæˆæäº¤ä¿¡æ¯å¹¶æäº¤
        const commitMessage = this.generateCommitMessage()
        await this.gitCommit(commitMessage)
        // console.log(`å·²æäº¤å˜æ›´: ${commitMessage}`)
      } else {
        // console.log('æ²¡æœ‰æ£€æµ‹åˆ°éœ€è¦æäº¤çš„å˜æ›´')
      }

      // 9. ç¡®ä¿æˆ‘ä»¬åœ¨æ­£ç¡®çš„åˆ†æ”¯ä¸Šå¹¶æ¨é€
      try {
        // å†æ¬¡ç¡®è®¤å½“å‰åˆ†æ”¯
        const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD'])
        // console.log(`æ¨é€å‰ç¡®è®¤å½“å‰åˆ†æ”¯: ${currentBranch}`)
        
        if (currentBranch !== targetBranch) {
          // console.log(`å½“å‰åˆ†æ”¯ ${currentBranch} ä¸ç›®æ ‡åˆ†æ”¯ ${targetBranch} ä¸ä¸€è‡´ï¼Œå°è¯•åˆ‡æ¢...`)
          await git.checkout(targetBranch)
        }
      } catch (branchCheckError) {
        console.warn('æ¨é€å‰åˆ†æ”¯æ£€æŸ¥å¤±è´¥:', branchCheckError)
      }

      // 10. æ¨é€åˆ°è¿œç¨‹ï¼ˆåªæœ‰åœ¨æœ‰æäº¤æ—¶æ‰æ¨é€ï¼‰
      if (hasUncommittedChanges) {
        // console.log(`å¼€å§‹æ¨é€åˆ†æ”¯ ${targetBranch} åˆ°è¿œç¨‹ä»“åº“...`)
        try {
          await this.gitPush(targetBranch)
          // console.log('æ¨é€åˆ°è¿œç¨‹ä»“åº“æˆåŠŸ')
        } catch (pushError) {
          const errorMessage = pushError instanceof Error ? pushError.message : 'æœªçŸ¥é”™è¯¯'
          console.error('æ¨é€å¤±è´¥:', errorMessage)
          
          // Giteeç‰¹æ®Šé”™è¯¯å¤„ç†
          if (this.config.provider === 'gitee') {
            if (errorMessage.includes('could not read Username') || 
                errorMessage.includes('Authentication failed')) {
              return {
                success: false,
                message: `Giteeæ¨é€å¤±è´¥ï¼\n\nå¯èƒ½åŸå› ï¼š\nâ€¢ Tokenæ²¡æœ‰æ¨é€æƒé™\nâ€¢ ä»“åº“è®¾ç½®äº†ä¿æŠ¤åˆ†æ”¯\n\nå»ºè®®ï¼š\n1. åœ¨Giteeä¸Šæ£€æŸ¥Tokenæƒé™\n2. æ£€æŸ¥ä»“åº“åˆ†æ”¯ä¿æŠ¤è®¾ç½®\n3. å°è¯•ä½¿ç”¨SSHè®¤è¯æ–¹å¼`,
              }
            }
          }
          
          if (errorMessage.includes('no upstream branch') || 
              errorMessage.includes('has no upstream branch') ||
              errorMessage.includes('upstream branch') ||
              errorMessage.includes('src refspec') ||
              hasUncommittedChanges) { // å¦‚æœæœ‰æ–°æäº¤ï¼Œå¾ˆå¯èƒ½éœ€è¦è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯
            // console.log('å°è¯•è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯å¹¶æ¨é€ï¼ˆé¦–æ¬¡æ¨é€ï¼‰...')
            
            try {
              await git.push('origin', targetBranch, ['--set-upstream'])
              // console.log('å·²è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯å¹¶æ¨é€æˆåŠŸï¼ˆé¦–æ¬¡æ¨é€ï¼‰')
            } catch (upstreamError) {
              // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯•å¼ºåˆ¶æ¨é€ï¼ˆç”¨äºç©ºä»“åº“ï¼‰
              const upstreamErrorMsg = upstreamError instanceof Error ? upstreamError.message : 'æœªçŸ¥é”™è¯¯'
              console.error('è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯å¤±è´¥:', upstreamErrorMsg)
              
              // Giteeç‰¹æ®Šé”™è¯¯å¤„ç†
              if (this.config.provider === 'gitee' && 
                  (upstreamErrorMsg.includes('could not read Username') || 
                   upstreamErrorMsg.includes('Authentication failed'))) {
                return {
                  success: false,
                  message: `Giteeé¦–æ¬¡æ¨é€å¤±è´¥ï¼\n\nè¯·å°è¯•ï¼š\n1. åœ¨Giteeä¸Šç¡®è®¤ä»“åº“å·²æ­£ç¡®åˆ›å»º\n2. æ£€æŸ¥ä»“åº“æƒé™è®¾ç½®\n3. è·å–æ–°çš„Tokenæˆ–å°è¯•SSHè®¤è¯æ–¹å¼`,
                }
              }
              
              if (upstreamErrorMsg.includes('non-fast-forward') || 
                  upstreamErrorMsg.includes('rejected')) {
                // console.log('å°è¯•å¼ºåˆ¶æ¨é€åˆ°ç©ºä»“åº“...')
                await git.push('origin', targetBranch, ['--set-upstream', '--force'])
                // console.log('å¼ºåˆ¶æ¨é€æˆåŠŸï¼ˆç©ºä»“åº“åˆå§‹åŒ–ï¼‰')
              } else {
                throw upstreamError
              }
            }
          } else {
            throw pushError
          }
        }
      }

      // 11. æ›´æ–°åŒæ­¥çŠ¶æ€
      const finalStatus = SettingsManager.getCloudSyncStatus()
      finalStatus.lastSyncTime = Date.now()
      finalStatus.lastError = null
      finalStatus.isConnected = true
      await SettingsManager.saveCloudSyncStatus(finalStatus)

      // 12. ç¡®ä¿VSCodeç•Œé¢åˆ·æ–°æ˜¾ç¤ºæœ€æ–°æ•°æ®
      if (autoMerged && this.storageManager) {
        try {
          // å¼ºåˆ¶åˆ·æ–°ç¼“å­˜å’Œç•Œé¢
          if (this.storageManager.clearCache) {
            this.storageManager.clearCache()
          }
          
          // è§¦å‘æ ‘è§†å›¾åˆ·æ–°
          if (this.context) {
            // é€šè¿‡å‘½ä»¤åˆ·æ–°æ ‘è§†å›¾
            await vscode.commands.executeCommand('starcode-snippets.refreshExplorer')
          }
        } catch (refreshError) {
          console.warn('åˆ·æ–°ç•Œé¢å¤±è´¥:', refreshError)
        }
      }

      // æ„å»ºæˆåŠŸæ¶ˆæ¯
      let successMessage = ''
      if (hasUncommittedChanges) {
        successMessage = `åŒæ­¥æˆåŠŸï¼å·²æäº¤å¹¶æ¨é€ ${mergedSnippets.length} ä¸ªä»£ç ç‰‡æ®µå’Œ ${mergedDirectories.length} ä¸ªç›®å½•åˆ°åˆ†æ”¯ ${targetBranch}`
        if (autoMerged) {
          const remoteCount = mergedSnippets.length - currentSnippets.length
          const remoteDirCount = mergedDirectories.length - currentDirectories.length
          
          if (remoteCount > 0 || remoteDirCount > 0) {
            successMessage += `\n\nğŸ”„ æ™ºèƒ½åˆå¹¶ï¼šå·²è‡ªåŠ¨åˆå¹¶è¿œç¨‹æ•°æ®å¹¶å¯¼å…¥åˆ°VSCodeä¸­`
            if (remoteCount > 0) successMessage += `\nâ€¢ æ–°å¢ä»£ç ç‰‡æ®µï¼š${remoteCount} ä¸ª`
            if (remoteDirCount > 0) successMessage += `\nâ€¢ æ–°å¢ç›®å½•ï¼š${remoteDirCount} ä¸ª`
            
            // æ·»åŠ å†²çªè§£å†³ä¿¡æ¯
            if (finalSnippetMergeResult) {
              const autoResolvedConflicts = finalSnippetMergeResult.conflicts.filter((c: any) => 
                c.resolution === 'auto_merge' || c.resolution === 'use_newer' || c.resolution === 'use_local' || c.resolution === 'use_remote'
              ).length
              if (autoResolvedConflicts > 0) {
                successMessage += `\nâ€¢ è‡ªåŠ¨è§£å†³å†²çªï¼š${autoResolvedConflicts} ä¸ªï¼ˆä½¿ç”¨æ™ºèƒ½åˆå¹¶ç®—æ³•ï¼‰`
              }
            }
            
            successMessage += `\n\næ‰€æœ‰è®¾å¤‡çš„æ•°æ®ç°å·²åŒæ­¥ï¼Œæ‚¨å¯ä»¥åœ¨ä¾§è¾¹æ ä¸­æŸ¥çœ‹å®Œæ•´çš„ä»£ç ç‰‡æ®µåˆ—è¡¨ã€‚\n\nğŸ’¡ å¦‚æœå‘ç°VSCodeä¸­çš„æ•°æ®ä¸Gitä»“åº“ä¸ä¸€è‡´ï¼Œå¯ä»¥ä½¿ç”¨"ä»Gitä»“åº“å¼ºåˆ¶å¯¼å…¥"å‘½ä»¤ä¿®å¤ã€‚`
          } else {
            if (finalSnippetMergeResult && finalDirectoryMergeResult) {
              const totalAutoResolved = finalSnippetMergeResult.conflicts.length + finalDirectoryMergeResult.conflicts.length
              if (totalAutoResolved > 0) {
                successMessage += `\n\nğŸ”„ æ™ºèƒ½åˆå¹¶ï¼šå·²è‡ªåŠ¨è§£å†³ ${totalAutoResolved} ä¸ªæ•°æ®å†²çª`
              } else {
                successMessage += `\n\nğŸ”„ æ•°æ®å·²æ˜¯æœ€æ–°çŠ¶æ€ï¼Œæ— éœ€åˆå¹¶`
              }
            } else {
              successMessage += `\n\nğŸ”„ æ•°æ®å·²æ˜¯æœ€æ–°çŠ¶æ€ï¼Œæ— éœ€åˆå¹¶`
            }
          }
        }
      } else {
        successMessage = `åŒæ­¥æˆåŠŸï¼æ•°æ®å·²æ˜¯æœ€æ–°çŠ¶æ€ï¼ˆåˆ†æ”¯: ${targetBranch}ï¼‰`
        if (autoMerged) {
          const remoteCount = mergedSnippets.length - currentSnippets.length
          const remoteDirCount = mergedDirectories.length - currentDirectories.length
          if (remoteCount > 0 || remoteDirCount > 0) {
            successMessage += `\n\nğŸ”„ æ™ºèƒ½åˆå¹¶ï¼šå·²è‡ªåŠ¨å¯¼å…¥è¿œç¨‹æ•°æ®åˆ°VSCodeä¸­`
            if (remoteCount > 0) successMessage += `\nâ€¢ æ–°å¢ä»£ç ç‰‡æ®µï¼š${remoteCount} ä¸ª`
            if (remoteDirCount > 0) successMessage += `\nâ€¢ æ–°å¢ç›®å½•ï¼š${remoteDirCount} ä¸ª`
            successMessage += `\nâ€¢ è‡ªåŠ¨è§£å†³äº†æ•°æ®å†²çªï¼ˆä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼‰`
            successMessage += `\n\næ‰€æœ‰è®¾å¤‡çš„æ•°æ®ç°å·²åŒæ­¥ï¼Œæ‚¨å¯ä»¥åœ¨ä¾§è¾¹æ ä¸­æŸ¥çœ‹å®Œæ•´çš„ä»£ç ç‰‡æ®µåˆ—è¡¨ã€‚\n\nğŸ’¡ å¦‚æœå‘ç°VSCodeä¸­çš„æ•°æ®ä¸Gitä»“åº“ä¸ä¸€è‡´ï¼Œå¯ä»¥ä½¿ç”¨"ä»Gitä»“åº“å¼ºåˆ¶å¯¼å…¥"å‘½ä»¤ä¿®å¤ã€‚`
          } else {
            successMessage += `\n\nğŸ”„ æ•°æ®å·²è‡ªåŠ¨åˆå¹¶å¹¶è§£å†³å†²çªï¼ˆä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼‰`
          }
        }
      }

      return {
        success: true,
        message: successMessage
      }

    } catch (error) {
      console.error('åŒæ­¥å¤±è´¥:', error)
      
      // æ›´æ–°é”™è¯¯çŠ¶æ€
      const errorStatus = SettingsManager.getCloudSyncStatus()
      errorStatus.lastError = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      errorStatus.isConnected = false
      await SettingsManager.saveCloudSyncStatus(errorStatus)
      
      return {
        success: false,
        message: `åŒæ­¥å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      }
    } finally {
      // æ¸…é™¤åŒæ­¥çŠ¶æ€
      const finalStatus = SettingsManager.getCloudSyncStatus()
      finalStatus.isSyncing = false
      await SettingsManager.saveCloudSyncStatus(finalStatus)
    }
  }

  /**
   * æ£€æŸ¥å˜æ›´é›†æ˜¯å¦åŒ…å«å˜æ›´ (ä¿æŒå…¼å®¹æ€§)
   */
  private hasChanges(changeSet: any): boolean {
    if (typeof changeSet === 'object' && changeSet.hasChanges !== undefined) {
      return changeSet.hasChanges
    }
    
    // å…¼å®¹æ—§æ ¼å¼
    return (
      changeSet.addedFiles?.length > 0 ||
      changeSet.modifiedFiles?.length > 0 ||
      changeSet.deletedFiles?.length > 0 ||
      changeSet.addedDirectories?.length > 0 ||
      changeSet.deletedDirectories?.length > 0
    )
  }

  /**
   * å¤„ç†Gitåˆå¹¶å†²çª
   * å½“æ£€æµ‹åˆ°å†²çªæ—¶ï¼Œæä¾›ç”¨æˆ·å‹å¥½çš„æŒ‡å¯¼å’Œè‡ªåŠ¨è§£å†³é€‰é¡¹
   */
  private async handleGitConflicts(conflictedFiles: string[]): Promise<SyncResult> {
    const conflictCount = conflictedFiles.length
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ä»£ç ç‰‡æ®µç›¸å…³çš„å†²çªæ–‡ä»¶
    const isSnippetConflict = conflictedFiles.some(file => 
      file.includes('snippets.json') || 
      file.includes('directories.json') || 
      file.includes('.starcode-meta.json')
    )
    
    let message: string
    
    if (isSnippetConflict) {
      // å¯¹äºä»£ç ç‰‡æ®µæ–‡ä»¶çš„å†²çªï¼Œæä¾›æ›´å…·ä½“çš„è§£å†³æ–¹æ¡ˆ
      message = `æ£€æµ‹åˆ°ä»£ç ç‰‡æ®µåŒæ­¥å†²çªï¼\n\n` +
        `å†²çªæ–‡ä»¶ï¼š\n${conflictedFiles.map(file => `â€¢ ${file}`).join('\n')}\n\n` +
        `è¿™é€šå¸¸å‘ç”Ÿåœ¨å¤šä¸ªè®¾å¤‡åŒæ—¶ä¿®æ”¹ä»£ç ç‰‡æ®µæ—¶ã€‚\n\n` +
        `è§£å†³æ–¹æ¡ˆï¼š\n` +
        `1. ã€æ¨èã€‘é‡ç½®æœ¬åœ°ä»“åº“å¹¶é‡æ–°åŒæ­¥ï¼š\n` +
        `   - è¿™ä¼šä½¿ç”¨è¿œç¨‹ç‰ˆæœ¬è¦†ç›–æœ¬åœ°å†²çª\n` +
        `   - æ‚¨çš„VSCodeä¸­çš„ä»£ç ç‰‡æ®µä¸ä¼šä¸¢å¤±\n` +
        `2. æ‰‹åŠ¨è§£å†³å†²çªï¼š\n` +
        `   - åœ¨VSCodeä¸­æ‰“å¼€å†²çªæ–‡ä»¶\n` +
        `   - ä½¿ç”¨å†…ç½®åˆå¹¶å·¥å…·é€‰æ‹©è¦ä¿ç•™çš„å†…å®¹\n` +
        `   - ä¿å­˜åé‡æ–°æ‰§è¡ŒåŒæ­¥\n\n` +
        `å»ºè®®ï¼šä¸ºé¿å…æ­¤ç±»å†²çªï¼Œè¯·åœ¨ä¸åŒè®¾å¤‡é—´é”™å¼€åŒæ­¥æ—¶é—´ã€‚`
    } else {
      // é€šç”¨å†²çªå¤„ç†
      message = `æ£€æµ‹åˆ° ${conflictCount} ä¸ªæ–‡ä»¶å­˜åœ¨åˆå¹¶å†²çªï¼š\n\n` +
        `å†²çªæ–‡ä»¶ï¼š\n${conflictedFiles.map(file => `â€¢ ${file}`).join('\n')}\n\n` +
        `è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤è§£å†³å†²çªï¼š\n` +
        `1. åœ¨VSCodeä¸­æ‰“å¼€å†²çªæ–‡ä»¶\n` +
        `2. ä½¿ç”¨VSCodeå†…ç½®çš„åˆå¹¶å·¥å…·è§£å†³å†²çª\n` +
        `3. ä¿å­˜æ–‡ä»¶åé‡æ–°æ‰§è¡ŒåŒæ­¥\n\n` +
        `æˆ–è€…ä½¿ç”¨Gitå‘½ä»¤è¡Œå·¥å…·æ‰‹åŠ¨è§£å†³å†²çªã€‚`
    }

    return {
      success: false,
      message: message,
      conflictsDetected: true,
      conflictDetails: conflictedFiles
    }
  }

  /**
   * é‡ç½®æœ¬åœ°Gitä»“åº“åˆ°è¿œç¨‹çŠ¶æ€
   * ç”¨äºè§£å†³æ— æ³•è‡ªåŠ¨åˆå¹¶çš„å†²çª
   */
  public async resetToRemote(branch?: string): Promise<{ success: boolean; message: string }> {
    try {
      const git = await this.getGitInstance()
      const targetBranch = branch || this.config.defaultBranch || 'main'
      
      // console.log(`é‡ç½®æœ¬åœ°ä»“åº“åˆ°è¿œç¨‹åˆ†æ”¯ ${targetBranch}...`)
      
      // å…ˆè·å–è¿œç¨‹æœ€æ–°çŠ¶æ€
      await git.fetch('origin', targetBranch)
      
      // é‡ç½®åˆ°è¿œç¨‹åˆ†æ”¯
      await git.reset(['--hard', `origin/${targetBranch}`])
      
      // æ¸…ç†æœªè·Ÿè¸ªçš„æ–‡ä»¶
      await git.clean('f', ['-d'])
      
      // console.log('æœ¬åœ°ä»“åº“å·²é‡ç½®åˆ°è¿œç¨‹çŠ¶æ€')
      
      return {
        success: true,
        message: `æœ¬åœ°Gitä»“åº“å·²é‡ç½®åˆ°è¿œç¨‹åˆ†æ”¯ ${targetBranch} çš„æœ€æ–°çŠ¶æ€ã€‚\nç°åœ¨å¯ä»¥é‡æ–°æ‰§è¡ŒåŒæ­¥æ“ä½œã€‚`
      }
    } catch (error) {
      console.error('é‡ç½®æœ¬åœ°ä»“åº“å¤±è´¥:', error)
      return {
        success: false,
        message: `é‡ç½®å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      }
    }
  }

  /**
   * æ¸…ç©ºæœ¬åœ°ä»£ç åº“ (May be adapted to clear local Git repo or reset it)
   */
  private async clearLocalCodebase(): Promise<void> {
    if (!this.storageManager) {
      throw new Error('StorageManager æœªåˆå§‹åŒ–')
    }
    // console.log('æ¸…ç©ºæœ¬åœ°ä»£ç åº“ (to be adapted for Git)...')
    try {
      const [snippets, directories] = await Promise.all([
        this.storageManager.getAllSnippets(),
        this.storageManager.getAllDirectories(),
      ])
      for (const snippet of snippets) {
        await this.storageManager.deleteSnippet(snippet.id)
      }
      // console.log(`å·²åˆ é™¤ ${snippets.length} ä¸ªä»£ç ç‰‡æ®µ (from StorageManager)`)
      const sortedDirs = directories.sort((a: DirectoryDeprecatedType, b: DirectoryDeprecatedType) => {
        return (b.name || '').localeCompare(a.name || '') // Placeholder sort
      })
      for (const directory of sortedDirs) {
        await this.storageManager.deleteDirectory(directory.id)
      }
      // console.log(`å·²åˆ é™¤ ${directories.length} ä¸ªç›®å½• (from StorageManager)`)
      if (this.storageManager.clearCache) {
        this.storageManager.clearCache()
      }
      // console.log('æœ¬åœ°ä»£ç åº“æ¸…ç©ºå®Œæˆ (StorageManager based)')
    } catch (error) {
      console.error('æ¸…ç©ºæœ¬åœ°ä»£ç åº“å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * ä»Gitä»“åº“å¼ºåˆ¶åŒæ­¥æ•°æ®åˆ°VSCodeå­˜å‚¨
   * ç”¨äºä¿®å¤åŒæ­¥ä¸ä¸€è‡´çš„é—®é¢˜
   */
  public async forceImportFromGitRepo(): Promise<{ success: boolean; message: string; imported: { snippets: number; directories: number } }> {
    if (!this.storageManager) {
      return {
        success: false,
        message: 'StorageManager æœªåˆå§‹åŒ–',
        imported: { snippets: 0, directories: 0 }
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ”¯æŒV2ç‰ˆæœ¬çš„è·¯å¾„æ“ä½œ
    const supportsV2Path = this.storageManager.getSnippetByPath && this.storageManager.getDirectoryByPath

    try {
      // 1. ä»Gitä»“åº“è¯»å–æœ€æ–°æ•°æ®
      const gitData = await this.readDataFromGitRepo()
      
      if (gitData.snippets.length === 0 && gitData.directories.length === 0) {
        return {
          success: true,
          message: 'Gitä»“åº“ä¸­æ²¡æœ‰æ•°æ®éœ€è¦å¯¼å…¥',
          imported: { snippets: 0, directories: 0 }
        }
      }

      // 2. è·å–å½“å‰VSCodeå­˜å‚¨ä¸­çš„æ•°æ®
      const currentSnippets = await this.storageManager.getAllSnippets()
      const currentDirectories = await this.storageManager.getAllDirectories()

      let importedSnippets = 0
      let importedDirectories = 0

      // 3. åŒæ­¥ç›®å½•
      for (const gitDirectory of gitData.directories) {
        const existingDir = currentDirectories.find((d: DirectoryDeprecatedType) => 
          (d as any).fullPath === (gitDirectory as any).fullPath
        )

        if (!existingDir) {
          // æ–°å¢ç›®å½•
          await this.storageManager.createDirectory(gitDirectory)
          importedDirectories++
        } else {
          // æ£€æŸ¥å¹¶æ›´æ–°ç°æœ‰ç›®å½•
          const hasDirectoryDiff = this.hasDirectoryContentDifference(existingDir, gitDirectory)
          if (hasDirectoryDiff) {
            // V2ç‰ˆæœ¬ï¼šåˆ é™¤ç°æœ‰ç›®å½•å¹¶é‡æ–°åˆ›å»ºï¼ˆå› ä¸ºæ²¡æœ‰åŸºäºè·¯å¾„çš„æ›´æ–°æ–¹æ³•ï¼‰
            // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ç°æœ‰ç›®å½•çš„IDï¼Œå› ä¸ºstorageManagerçš„deleteDirectoryæ–¹æ³•éœ€è¦ID
            if ((existingDir as any).id) {
              await this.storageManager.deleteDirectory((existingDir as any).id)
            } else {
              // å¦‚æœæ²¡æœ‰IDï¼Œå°è¯•ä½¿ç”¨è·¯å¾„ç”Ÿæˆçš„ID
              const pathBasedId = require('./pathBasedManager').PathBasedManager.generateIdFromPath((gitDirectory as any).fullPath)
              await this.storageManager.deleteDirectory(pathBasedId)
            }
            await this.storageManager.createDirectory(gitDirectory)
            importedDirectories++
          }
        }
      }

      // 4. åŒæ­¥ä»£ç ç‰‡æ®µ
      for (const gitSnippet of gitData.snippets) {
        const existingSnippet = currentSnippets.find((s: CodeSnippetDeprecatedType) => 
          (s as any).fullPath === (gitSnippet as any).fullPath
        )

        if (!existingSnippet) {
          // æ–°å¢ä»£ç ç‰‡æ®µ
          await this.storageManager.saveSnippet(gitSnippet)
          importedSnippets++
        } else {
          // æ£€æŸ¥å¹¶æ›´æ–°ç°æœ‰ä»£ç ç‰‡æ®µ
          const hasSnippetDiff = this.hasSnippetContentDifference(existingSnippet, gitSnippet)
          if (hasSnippetDiff) {
            // V2ç‰ˆæœ¬ï¼šåˆ é™¤ç°æœ‰ä»£ç ç‰‡æ®µå¹¶é‡æ–°åˆ›å»ºï¼ˆå› ä¸ºæ²¡æœ‰åŸºäºè·¯å¾„çš„æ›´æ–°æ–¹æ³•ï¼‰
            // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ç°æœ‰ä»£ç ç‰‡æ®µçš„IDï¼Œå› ä¸ºstorageManagerçš„deleteSnippetæ–¹æ³•éœ€è¦ID
            if ((existingSnippet as any).id) {
              await this.storageManager.deleteSnippet((existingSnippet as any).id)
            } else {
              // å¦‚æœæ²¡æœ‰IDï¼Œå°è¯•ä½¿ç”¨è·¯å¾„ç”Ÿæˆçš„ID
              const pathBasedId = require('./pathBasedManager').PathBasedManager.generateIdFromPath((gitSnippet as any).fullPath)
              await this.storageManager.deleteSnippet(pathBasedId)
            }
            await this.storageManager.saveSnippet(gitSnippet)
            importedSnippets++
          }
        }
      }

      // 5. æ¸…é™¤ç¼“å­˜å¹¶åˆ·æ–°ç•Œé¢
      if (this.storageManager.clearCache) {
        this.storageManager.clearCache()
      }

      if (this.context) {
        try {
          await vscode.commands.executeCommand('starcode-snippets.refreshExplorer')
        } catch (refreshError) {
          console.warn('åˆ·æ–°ç•Œé¢å¤±è´¥:', refreshError)
        }
      }

      return {
        success: true,
        message: `æˆåŠŸä»Gitä»“åº“å¯¼å…¥æ•°æ®ï¼\n\nâ€¢ æ›´æ–°/æ–°å¢ä»£ç ç‰‡æ®µï¼š${importedSnippets} ä¸ª\nâ€¢ æ›´æ–°/æ–°å¢ç›®å½•ï¼š${importedDirectories} ä¸ª\n\næ‰€æœ‰æ•°æ®ç°å·²ä¸Gitä»“åº“ä¿æŒä¸€è‡´ã€‚`,
        imported: { snippets: importedSnippets, directories: importedDirectories }
      }

    } catch (error) {
      console.error('ä»Gitä»“åº“å¼ºåˆ¶å¯¼å…¥æ•°æ®å¤±è´¥:', error)
      return {
        success: false,
        message: `å¯¼å…¥å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,
        imported: { snippets: 0, directories: 0 }
      }
    }
  }

  /**
   * åº”ç”¨ç”¨æˆ·æ‰‹åŠ¨è§£å†³çš„å†²çªæ–‡ä»¶
   * è¯»å–ä¸´æ—¶å†²çªæ–‡ä»¶ä¸­ç”¨æˆ·ç¼–è¾‘åçš„å†…å®¹å¹¶åº”ç”¨åˆ°åŒæ­¥è¿‡ç¨‹
   */
  public async applyResolvedConflicts(): Promise<{
    success: boolean
    message: string
    resolvedCount: number
    resolvedSnippets?: CodeSnippetDeprecatedType[]
  }> {
    try {
      const effectiveLocalPath = SettingsManager.getEffectiveLocalPath()
      const tempDir = path.join(effectiveLocalPath, '.merge-conflicts')
      
      if (!fs.existsSync(tempDir)) {
        return {
          success: false,
          message: 'æ²¡æœ‰æ‰¾åˆ°å¾…è§£å†³çš„å†²çªæ–‡ä»¶',
          resolvedCount: 0
        }
      }
      
      // è¯»å–æ‰€æœ‰å†²çªæ–‡ä»¶
      const conflictFiles = fs.readdirSync(tempDir).filter(file => file.startsWith('conflict_') && file.endsWith('.txt'))
      
      if (conflictFiles.length === 0) {
        return {
          success: false,
          message: 'å†²çªç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ°å†²çªæ–‡ä»¶',
          resolvedCount: 0
        }
      }
      
      const resolvedSnippets: any[] = []
      let resolvedCount = 0
      
      for (const fileName of conflictFiles) {
        const filePath = path.join(tempDir, fileName)
        const fileContent = fs.readFileSync(filePath, 'utf8')
        
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²ç»è¢«ç”¨æˆ·ç¼–è¾‘ï¼ˆä¸åŒ…å«å†²çªæ ‡è®°ï¼‰
        const hasConflictMarkers = fileContent.includes('<<<<<<< LOCAL') || 
                                 fileContent.includes('=======') || 
                                 fileContent.includes('>>>>>>> REMOTE')
        
        if (!hasConflictMarkers) {
          // ç”¨æˆ·å·²ç»è§£å†³äº†å†²çªï¼Œæå–è§£å†³åçš„ä»£ç å†…å®¹
          const resolvedResult = this.extractResolvedContent(fileContent)
          
          if (resolvedResult.success && resolvedResult.content.length > 0) {
            // ä»æ–‡ä»¶åä¸­æå–å†²çªè·¯å¾„
            const pathMatch = fileName.match(/conflict_\d+_(.+)\.txt$/)
            if (pathMatch) {
              const conflictPath = pathMatch[1].replace(/_/g, '/')
              
                             // åˆ›å»ºè§£å†³åçš„ä»£ç ç‰‡æ®µå¯¹è±¡
               const resolvedSnippet = {
                 id: require('crypto').randomUUID(), // ç”Ÿæˆæ–°çš„ID
                 fullPath: conflictPath,
                 name: path.basename(conflictPath),
                 code: resolvedResult.content,
                 language: '', // å°†åœ¨å¯¼å…¥æ—¶è‡ªåŠ¨æ£€æµ‹
                 category: path.dirname(conflictPath) === '.' ? '' : path.dirname(conflictPath),
                 createTime: Date.now()
               } as any
              
              resolvedSnippets.push(resolvedSnippet)
              resolvedCount++
            }
          }
        }
      }
      
             if (resolvedCount === 0) {
         return {
           success: false,
           message: `å‘ç° ${conflictFiles.length} ä¸ªå†²çªæ–‡ä»¶ï¼Œä½†éƒ½å°šæœªè§£å†³ã€‚\n\nè¯·æŒ‰ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š\n1. æ‰“å¼€å†²çªæ–‡ä»¶è¿›è¡Œç¼–è¾‘\n2. ä¿ç•™æ‚¨æƒ³è¦çš„å†…å®¹\n3. åˆ é™¤å†²çªæ ‡è®°è¡Œï¼ˆ<<<<<<< ======= >>>>>>>ï¼‰\n4. ä¿å­˜æ–‡ä»¶ - ç³»ç»Ÿå°†è‡ªåŠ¨æ£€æµ‹å¹¶åº”ç”¨è§£å†³æ–¹æ¡ˆ`,
           resolvedCount: 0
         }
       }
      
      // åº”ç”¨è§£å†³åçš„ä»£ç ç‰‡æ®µåˆ°VSCodeå­˜å‚¨
      if (this.storageManager && resolvedSnippets.length > 0) {
        for (const snippet of resolvedSnippets) {
          try {
            await this.storageManager.saveSnippet(snippet)
          } catch (saveError) {
            console.warn(`ä¿å­˜è§£å†³åçš„ä»£ç ç‰‡æ®µå¤±è´¥: ${(snippet as any).fullPath}`, saveError)
          }
        }
        
        // æ¸…é™¤ç¼“å­˜å¹¶åˆ·æ–°ç•Œé¢
        if (this.storageManager.clearCache) {
          this.storageManager.clearCache()
        }
        
        if (this.context) {
          try {
            await vscode.commands.executeCommand('starcode-snippets.refreshExplorer')
          } catch (refreshError) {
            console.warn('åˆ·æ–°ç•Œé¢å¤±è´¥:', refreshError)
          }
        }
      }
      
      // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempConflictFiles(tempDir)
      
      return {
        success: true,
                 message: `æˆåŠŸåº”ç”¨ ${resolvedCount} ä¸ªæ‰‹åŠ¨è§£å†³çš„å†²çªï¼\n\nå·²æ›´æ–°çš„ä»£ç ç‰‡æ®µï¼š\n${resolvedSnippets.map(s => `â€¢ ${(s as any).fullPath}`).join('\n')}\n\nç°åœ¨å¯ä»¥é‡æ–°æ‰§è¡ŒåŒæ­¥æ“ä½œã€‚`,
        resolvedCount,
        resolvedSnippets
      }
      
    } catch (error) {
      console.error('åº”ç”¨è§£å†³åçš„å†²çªå¤±è´¥:', error)
      return {
        success: false,
        message: `åº”ç”¨å†²çªè§£å†³å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,
        resolvedCount: 0
      }
    }
  }

  /**
   * å¼ºåˆ¶æ¨é€åˆ°äº‘ç«¯ï¼ˆå±é™©æ“ä½œï¼‰
   * ç”¨äºåœ¨ç”¨æˆ·æ˜ç¡®ç¡®è®¤çš„æƒ…å†µä¸‹è¦†ç›–è¿œç¨‹æ•°æ®
   */
  public async forcePushToCloud(currentSnippets: CodeSnippetDeprecatedType[], currentDirectories: DirectoryDeprecatedType[], userConfirmed: boolean = false): Promise<SyncResult> {
    if (!this.isConfigured()) {
      return {
        success: false,
        message: 'äº‘ç«¯åŒæ­¥æœªé…ç½®ï¼Œè¯·å…ˆé…ç½®Gitä»“åº“ä¿¡æ¯'
      }
    }

    if (!userConfirmed) {
      return {
        success: false,
        message: 'âš ï¸ å¼ºåˆ¶æ¨é€éœ€è¦ç”¨æˆ·ç¡®è®¤ï¼\n\nå¼ºåˆ¶æ¨é€ä¼šè¦†ç›–è¿œç¨‹ä»“åº“çš„æ‰€æœ‰æ•°æ®ï¼Œè¿™ä¸ªæ“ä½œä¸å¯æ’¤é”€ã€‚\n\nå¦‚æœæ‚¨ç¡®å®šè¦ç»§ç»­ï¼Œè¯·ä½¿ç”¨ç¡®è®¤å‚æ•°è°ƒç”¨æ­¤æ–¹æ³•ã€‚'
      }
    }

    // æ›´æ–°åŒæ­¥çŠ¶æ€
    const status = SettingsManager.getCloudSyncStatus()
    status.isSyncing = true
    await SettingsManager.saveCloudSyncStatus(status)

    try {
      // console.log('å¼€å§‹å¼ºåˆ¶æ¨é€åˆ°äº‘ç«¯...')
      
      // 1. è·å–Gitå®ä¾‹
      const git = await this.getGitInstance()
      
      // 2. ç¡®ä¿åœ¨æ­£ç¡®çš„åˆ†æ”¯ä¸Š
      const targetBranch = this.config.defaultBranch || 'main'
      try {
        const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD'])
        if (currentBranch !== targetBranch) {
          const localBranches = await git.branchLocal()
          if (!localBranches.all.includes(targetBranch)) {
            await git.checkoutLocalBranch(targetBranch)
          } else {
            await git.checkout(targetBranch)
          }
        }
      } catch (branchError) {
        console.warn('åˆ†æ”¯æ£€æŸ¥å¤±è´¥:', branchError)
      }
      
      // 3. å¼ºåˆ¶å†™å…¥æœ¬åœ°æ•°æ®ï¼ˆå§‹ç»ˆæ›´æ–°æ—¶é—´æˆ³ï¼‰
      await this.writeDataToGitRepo(currentSnippets, currentDirectories, true)
      
      // 4. æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´éœ€è¦æäº¤
      const gitStatus = await this.gitStatus()
      const hasChanges = gitStatus.files.length > 0
      
      if (hasChanges) {
        // 5. æ·»åŠ æ‰€æœ‰å˜æ›´å¹¶æäº¤
        await this.gitAddAll()
        const commitMessage = this.generateCommitMessage() + ' [FORCE PUSH]'
        await this.gitCommit(commitMessage)
        // console.log(`å·²æäº¤å˜æ›´: ${commitMessage}`)
      } else {
        // å¦‚æœæ²¡æœ‰å˜æ›´ï¼Œåˆ›å»ºä¸€ä¸ªç©ºæäº¤ä»¥ç¡®ä¿æ¨é€
        const emptyCommitMessage = this.generateCommitMessage() + ' [FORCE PUSH - NO CHANGES]'
        await git.commit(emptyCommitMessage, ['--allow-empty'])
        // console.log(`å·²åˆ›å»ºç©ºæäº¤: ${emptyCommitMessage}`)
      }
      
      // 6. å¼ºåˆ¶æ¨é€åˆ°è¿œç¨‹
      try {
        await git.push('origin', targetBranch, ['--force', '--set-upstream'])
        // console.log('å¼ºåˆ¶æ¨é€æˆåŠŸ')
      } catch (pushError) {
        const errorMessage = pushError instanceof Error ? pushError.message : 'æœªçŸ¥é”™è¯¯'
        
        if (errorMessage.includes('no upstream branch') || 
            errorMessage.includes('src refspec')) {
          // å°è¯•è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯
          await git.push('origin', targetBranch, ['--set-upstream', '--force'])
          // console.log('è®¾ç½®ä¸Šæ¸¸åˆ†æ”¯å¹¶å¼ºåˆ¶æ¨é€æˆåŠŸ')
        } else {
          throw pushError
        }
      }
      
      // 7. æ›´æ–°åŒæ­¥çŠ¶æ€
      const finalStatus = SettingsManager.getCloudSyncStatus()
      finalStatus.lastSyncTime = Date.now()
      finalStatus.lastError = null
      finalStatus.isConnected = true
      await SettingsManager.saveCloudSyncStatus(finalStatus)
      
      return {
        success: true,
        message: `å¼ºåˆ¶æ¨é€æˆåŠŸï¼\n\nå·²å¼ºåˆ¶è¦†ç›–è¿œç¨‹ä»“åº“æ•°æ®ï¼š\nâ€¢ ${currentSnippets.length} ä¸ªä»£ç ç‰‡æ®µ\nâ€¢ ${currentDirectories.length} ä¸ªç›®å½•\n\nåˆ†æ”¯: ${targetBranch}\n\nâš ï¸ è¿œç¨‹ä»“åº“çš„å†å²æ•°æ®å·²è¢«è¦†ç›–ã€‚`
      }
      
    } catch (error) {
      console.error('å¼ºåˆ¶æ¨é€å¤±è´¥:', error)
      
      // æ›´æ–°é”™è¯¯çŠ¶æ€
      const errorStatus = SettingsManager.getCloudSyncStatus()
      errorStatus.lastError = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      errorStatus.isConnected = false
      await SettingsManager.saveCloudSyncStatus(errorStatus)
      
      return {
        success: false,
        message: `å¼ºåˆ¶æ¨é€å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`
      }
    } finally {
      // æ¸…é™¤åŒæ­¥çŠ¶æ€
      const finalStatus = SettingsManager.getCloudSyncStatus()
      finalStatus.isSyncing = false
      await SettingsManager.saveCloudSyncStatus(finalStatus)
    }
  }
}
